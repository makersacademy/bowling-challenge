/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./test/after.spec.js":
/*!****************************!*\
  !*** ./test/after.spec.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const callSpy = __webpack_require__(/*! ./lib/callSpy */ "./test/lib/callSpy.js");

describe('any.after', () => {
  const shared = {};
  beforeEach(() => {
    shared.spy = callSpy(new Date('2013-01-01T00:00:00.000Z'));
  });
  it('should confirm', () => {
    expect(shared.spy).toHaveBeenCalledWith(
      any.after(new Date('1998-08-12T01:00:00.000Z'))
    );
  });
});


/***/ }),

/***/ "./test/arrayOfBooleans.spec.js":
/*!**************************************!*\
  !*** ./test/arrayOfBooleans.spec.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const callSpy = __webpack_require__(/*! ./lib/callSpy */ "./test/lib/callSpy.js");

describe('any.arrayOfBooleans', () => {
  const shared = {};
  beforeEach(() => {
    shared.spy = callSpy([true, false, new Boolean(true), new Boolean(false)]);
  });
  it('should confirm', () => {
    expect(shared.spy).toHaveBeenCalledWith(any.arrayOfBooleans());
  });
});


/***/ }),

/***/ "./test/arrayOfNumbers.spec.js":
/*!*************************************!*\
  !*** ./test/arrayOfNumbers.spec.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const callSpy = __webpack_require__(/*! ./lib/callSpy */ "./test/lib/callSpy.js");

describe('any.arrayOfNumbers', () => {
  const shared = {};
  beforeEach(() => {
    shared.spy = callSpy([1, new Number(6)]);
  });
  it('should confirm', () => {
    expect(shared.spy).toHaveBeenCalledWith(any.arrayOfNumbers());
  });
});


/***/ }),

/***/ "./test/arrayOfObjects.spec.js":
/*!*************************************!*\
  !*** ./test/arrayOfObjects.spec.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const callSpy = __webpack_require__(/*! ./lib/callSpy */ "./test/lib/callSpy.js");

describe('any.arrayOfObjects', () => {
  const shared = {};
  beforeEach(() => {
    shared.spy = callSpy([{}, new Object()]);
  });
  it('should confirm', () => {
    expect(shared.spy).toHaveBeenCalledWith(any.arrayOfObjects());
  });
});


/***/ }),

/***/ "./test/arrayOfSize.spec.js":
/*!**********************************!*\
  !*** ./test/arrayOfSize.spec.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const callSpy = __webpack_require__(/*! ./lib/callSpy */ "./test/lib/callSpy.js");

describe('any.arrayOfSize', () => {
  const shared = {};
  beforeEach(() => {
    shared.spy = callSpy(['a', 'b', 'c']);
  });
  it('should confirm', () => {
    expect(shared.spy).toHaveBeenCalledWith(any.arrayOfSize(3));
  });
});


/***/ }),

/***/ "./test/arrayOfStrings.spec.js":
/*!*************************************!*\
  !*** ./test/arrayOfStrings.spec.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const callSpy = __webpack_require__(/*! ./lib/callSpy */ "./test/lib/callSpy.js");

describe('any.arrayOfStrings', () => {
  const shared = {};
  beforeEach(() => {
    shared.spy = callSpy(['', ' ', new String('hello')]);
  });
  it('should confirm', () => {
    expect(shared.spy).toHaveBeenCalledWith(any.arrayOfStrings());
  });
});


/***/ }),

/***/ "./test/before.spec.js":
/*!*****************************!*\
  !*** ./test/before.spec.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const callSpy = __webpack_require__(/*! ./lib/callSpy */ "./test/lib/callSpy.js");

describe('any.before', () => {
  const shared = {};
  beforeEach(() => {
    shared.spy = callSpy(new Date('1998-08-12T01:00:00.000Z'));
  });
  it('should confirm', () => {
    expect(shared.spy).toHaveBeenCalledWith(
      any.before(new Date('2013-01-01T00:00:00.000Z'))
    );
  });
});


/***/ }),

/***/ "./test/calculable.spec.js":
/*!*********************************!*\
  !*** ./test/calculable.spec.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const callSpy = __webpack_require__(/*! ./lib/callSpy */ "./test/lib/callSpy.js");

describe('any.calculable', () => {
  const shared = {};
  beforeEach(() => {
    shared.spy = callSpy('1');
  });
  it('should confirm', () => {
    expect(shared.spy).toHaveBeenCalledWith(any.calculable());
  });
});


/***/ }),

/***/ "./test/emptyArray.spec.js":
/*!*********************************!*\
  !*** ./test/emptyArray.spec.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const callSpy = __webpack_require__(/*! ./lib/callSpy */ "./test/lib/callSpy.js");

describe('any.emptyArray', () => {
  const shared = {};
  beforeEach(() => {
    shared.spy = callSpy([]);
  });
  it('should confirm', () => {
    expect(shared.spy).toHaveBeenCalledWith(any.emptyArray());
  });
});


/***/ }),

/***/ "./test/emptyObject.spec.js":
/*!**********************************!*\
  !*** ./test/emptyObject.spec.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const callSpy = __webpack_require__(/*! ./lib/callSpy */ "./test/lib/callSpy.js");

describe('any.emptyObject', () => {
  const shared = {};
  beforeEach(() => {
    shared.spy = callSpy({});
  });
  it('should confirm', () => {
    expect(shared.spy).toHaveBeenCalledWith(any.emptyObject());
  });
});


/***/ }),

/***/ "./test/endingWith.spec.js":
/*!*********************************!*\
  !*** ./test/endingWith.spec.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const callSpy = __webpack_require__(/*! ./lib/callSpy */ "./test/lib/callSpy.js");

describe('any.endingWith', () => {
  const shared = {};
  beforeEach(() => {
    shared.spy = callSpy('Guybrush Threepwood');
  });
  it('should confirm', () => {
    expect(shared.spy).toHaveBeenCalledWith(any.endingWith('eepwood'));
  });
});


/***/ }),

/***/ "./test/evenNumber.spec.js":
/*!*********************************!*\
  !*** ./test/evenNumber.spec.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const callSpy = __webpack_require__(/*! ./lib/callSpy */ "./test/lib/callSpy.js");

describe('any.evenNumber', () => {
  const shared = {};
  beforeEach(() => {
    shared.spy = callSpy(4);
  });
  it('should confirm', () => {
    expect(shared.spy).toHaveBeenCalledWith(any.evenNumber());
  });
});


/***/ }),

/***/ "./test/greaterThanOrEqualTo.spec.js":
/*!*******************************************!*\
  !*** ./test/greaterThanOrEqualTo.spec.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const callSpy = __webpack_require__(/*! ./lib/callSpy */ "./test/lib/callSpy.js");

describe('any.greaterThanOrEqualTo', () => {
  const shared = {};
  beforeEach(() => {
    shared.spy = callSpy(8);
    shared.spy2 = callSpy(9);
  });
  it('should confirm', () => {
    expect(shared.spy).toHaveBeenCalledWith(any.greaterThanOrEqualTo(8));
    expect(shared.spy2).toHaveBeenCalledWith(any.greaterThanOrEqualTo(8));
  });
});


/***/ }),

/***/ "./test/iso8601.spec.js":
/*!******************************!*\
  !*** ./test/iso8601.spec.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const callSpy = __webpack_require__(/*! ./lib/callSpy */ "./test/lib/callSpy.js");

describe('any.iso8601', () => {
  const shared = {};
  beforeEach(() => {
    shared.spy = callSpy('2013-07-08T07:29:15.863Z');
  });
  it('should confirm', () => {
    expect(shared.spy).toHaveBeenCalledWith(any.iso8601());
  });
});


/***/ }),

/***/ "./test/jsonString.spec.js":
/*!*********************************!*\
  !*** ./test/jsonString.spec.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const callSpy = __webpack_require__(/*! ./lib/callSpy */ "./test/lib/callSpy.js");

describe('any.jsonString', () => {
  const shared = {};
  beforeEach(() => {
    shared.spy = callSpy('{}');
  });
  it('should confirm', () => {
    expect(shared.spy).toHaveBeenCalledWith(any.jsonString());
  });
});


/***/ }),

/***/ "./test/lessThanOrEqualTo.spec.js":
/*!****************************************!*\
  !*** ./test/lessThanOrEqualTo.spec.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const callSpy = __webpack_require__(/*! ./lib/callSpy */ "./test/lib/callSpy.js");

describe('any.lessThanOrEqualTo', () => {
  const shared = {};
  beforeEach(() => {
    shared.spy = callSpy(8);
    shared.spy2 = callSpy(9);
  });
  it('should confirm', () => {
    expect(shared.spy).toHaveBeenCalledWith(any.lessThanOrEqualTo(9));
    expect(shared.spy2).toHaveBeenCalledWith(any.lessThanOrEqualTo(9));
  });
});


/***/ }),

/***/ "./test/lib/callSpy.js":
/*!*****************************!*\
  !*** ./test/lib/callSpy.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function callSpy(arg) {
  const spy = jasmine.createSpy();
  spy(arg);
  return spy;
};


/***/ }),

/***/ "./test/lib/describeToBeArrayOfX.js":
/*!******************************************!*\
  !*** ./test/lib/describeToBeArrayOfX.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeWhenNotArray = __webpack_require__(/*! ./describeWhenNotArray */ "./test/lib/describeWhenNotArray.js");

module.exports = function describeToBeArrayOfX(name, options) {
  describe(name, () => {
    describe('when invoked', () => {
      describe('when subject is a true Array', () => {
        describe('when subject has no members', () => {
          it(
            'should confirm (an empty array of ' + options.type + 's is valid)',
            () => {
              expect([])[name]();
            }
          );
        });
        describe('when subject has members', () => {
          describe(
            'when subject has a mix of ' + options.type + 's and other items',
            () => {
              it('should deny', options.whenMixed);
            }
          );
          describe('when subject has only ' + options.type + 's', () => {
            it('should confirm', options.whenValid);
          });
          describe('when subject has other items', () => {
            it('should deny', options.whenInvalid);
          });
        });
      });
      describeWhenNotArray(name);
    });
  });
};


/***/ }),

/***/ "./test/lib/describeToHaveArrayX.js":
/*!******************************************!*\
  !*** ./test/lib/describeToHaveArrayX.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveX = __webpack_require__(/*! ./describeToHaveX */ "./test/lib/describeToHaveX.js");

module.exports = function describeToHaveArrayX(name, whenArray) {
  describeToHaveX(name, () => {
    describe('when member is an array', whenArray);
  });
};


/***/ }),

/***/ "./test/lib/describeToHaveBooleanX.js":
/*!********************************************!*\
  !*** ./test/lib/describeToHaveBooleanX.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveX = __webpack_require__(/*! ./describeToHaveX */ "./test/lib/describeToHaveX.js");

module.exports = function describeToHaveBooleanX(name, whenBoolean) {
  describeToHaveX(name, () => {
    describe('when member is truthy', () => {
      it('should deny', () => {
        expect({
          memberName: 1
        }).not[name]('memberName');
        expect({
          memberName: 'true'
        }).not[name]('memberName');
      });
    });
    describe('when member is falsy', () => {
      it('should deny', () => {
        expect({
          memberName: 0
        }).not[name]('memberName');
        expect({
          memberName: ''
        }).not[name]('memberName');
      });
    });
    describe('when member is boolean', whenBoolean);
  });
};


/***/ }),

/***/ "./test/lib/describeToHaveX.js":
/*!*************************************!*\
  !*** ./test/lib/describeToHaveX.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function describeToHaveX(name, whenPresent) {
  describe('when invoked', () => {
    describe('when subject is not an object', () => {
      it('should deny', () => {
        expect(0).not[name]('memberName');
        expect(null).not[name]('memberName');
        expect(true).not[name]('memberName');
        expect(false).not[name]('memberName');
        expect('').not[name]('memberName');
      });
    });
    describe('when subject is an object', () => {
      describe('when member is not present', () => {
        it('should deny', () => {
          expect({}).not[name]('memberName');
        });
      });
      describe('when member is present', () => {
        whenPresent();
      });
    });
  });
};


/***/ }),

/***/ "./test/lib/describeWhenNotArray.js":
/*!******************************************!*\
  !*** ./test/lib/describeWhenNotArray.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const getArgumentsObject = __webpack_require__(/*! ./getArgumentsObject */ "./test/lib/getArgumentsObject.js");
const getArrayLikeObject = __webpack_require__(/*! ./getArrayLikeObject */ "./test/lib/getArrayLikeObject.js");

module.exports = function describeWhenNotArray(toBeArrayMemberName) {
  describe('when subject is not a true Array', () => {
    describe('when subject is Array-like', () => {
      it('should deny', () => {
        expect(getArgumentsObject()).not[toBeArrayMemberName]();
        expect(getArrayLikeObject()).not[toBeArrayMemberName]();
      });
    });
    describe('when subject is not Array-like', () => {
      it('should deny', () => {
        let _undefined;
        expect({}).not[toBeArrayMemberName]();
        expect(null).not[toBeArrayMemberName]();
        expect(_undefined).not[toBeArrayMemberName]();
        expect(true).not[toBeArrayMemberName]();
        expect(false).not[toBeArrayMemberName]();
        expect(Array).not[toBeArrayMemberName]();
      });
    });
  });
};


/***/ }),

/***/ "./test/lib/getArgumentsObject.js":
/*!****************************************!*\
  !*** ./test/lib/getArgumentsObject.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function getArgumentsObject() {
  return (function() {
    return arguments;
  })(1, 2, 3);
};


/***/ }),

/***/ "./test/lib/getArrayLikeObject.js":
/*!****************************************!*\
  !*** ./test/lib/getArrayLikeObject.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function getArrayLikeObject() {
  return {
    0: 1,
    1: 2,
    2: 3,
    length: 3
  };
};


/***/ }),

/***/ "./test/longerThan.spec.js":
/*!*********************************!*\
  !*** ./test/longerThan.spec.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const callSpy = __webpack_require__(/*! ./lib/callSpy */ "./test/lib/callSpy.js");

describe('any.longerThan', () => {
  const shared = {};
  beforeEach(() => {
    shared.spy = callSpy('antidisestablishmentarianism');
  });
  it('should confirm', () => {
    expect(shared.spy).toHaveBeenCalledWith(any.longerThan('dog'));
  });
});


/***/ }),

/***/ "./test/nonEmptyArray.spec.js":
/*!************************************!*\
  !*** ./test/nonEmptyArray.spec.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const callSpy = __webpack_require__(/*! ./lib/callSpy */ "./test/lib/callSpy.js");

describe('any.nonEmptyArray', () => {
  const shared = {};
  beforeEach(() => {
    shared.spy = callSpy([0, false, 1, true]);
  });
  it('should confirm', () => {
    expect(shared.spy).toHaveBeenCalledWith(any.nonEmptyArray());
  });
});


/***/ }),

/***/ "./test/nonEmptyObject.spec.js":
/*!*************************************!*\
  !*** ./test/nonEmptyObject.spec.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const callSpy = __webpack_require__(/*! ./lib/callSpy */ "./test/lib/callSpy.js");

describe('any.nonEmptyObject', () => {
  const shared = {};
  beforeEach(() => {
    shared.spy = callSpy({
      prop: 'value'
    });
  });
  it('should confirm', () => {
    expect(shared.spy).toHaveBeenCalledWith(any.nonEmptyObject());
  });
});


/***/ }),

/***/ "./test/nonEmptyString.spec.js":
/*!*************************************!*\
  !*** ./test/nonEmptyString.spec.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const callSpy = __webpack_require__(/*! ./lib/callSpy */ "./test/lib/callSpy.js");

describe('any.nonEmptyString', () => {
  const shared = {};
  beforeEach(() => {
    shared.spy = callSpy('hello world');
  });
  it('should confirm', () => {
    expect(shared.spy).toHaveBeenCalledWith(any.nonEmptyString());
  });
});


/***/ }),

/***/ "./test/oddNumber.spec.js":
/*!********************************!*\
  !*** ./test/oddNumber.spec.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const callSpy = __webpack_require__(/*! ./lib/callSpy */ "./test/lib/callSpy.js");

describe('any.oddNumber', () => {
  const shared = {};
  beforeEach(() => {
    shared.spy = callSpy(3);
  });
  it('should confirm', () => {
    expect(shared.spy).toHaveBeenCalledWith(any.oddNumber());
  });
});


/***/ }),

/***/ "./test/optionalMessages.spec.js":
/*!***************************************!*\
  !*** ./test/optionalMessages.spec.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

it('should handle optional messages', () => {
  const MSG = 'some optional message';
  let _undefined;
  expect(new Date('2013-01-01T01:00:00.000Z')).toBeAfter(
    new Date('2013-01-01T00:00:00.000Z'),
    MSG
  );
  expect([]).toBeArray(MSG);
  expect([]).toBeArrayOfSize(0, MSG);
  expect(new Date('2013-01-01T00:00:00.000Z')).toBeBefore(
    new Date('2013-01-01T01:00:00.000Z'),
    MSG
  );
  expect(true).toBeBoolean(MSG);
  expect('1').toBeCalculable(MSG);
  expect(new Date()).toBeDate(MSG);
  expect([]).toBeEmptyArray(MSG);
  expect({}).toBeEmptyObject(MSG);
  expect('').toBeEmptyString(MSG);
  expect(2).toBeEvenNumber(MSG);
  expect(false).toBeFalse(MSG);
  expect(() => {}).toBeFunction(MSG);
  expect('<element>text</element>').toBeHtmlString(MSG);
  expect('2013-07-08T07:29:15.863Z').toBeIso8601(MSG);
  expect('{}').toBeJsonString(MSG);
  expect('abc').toBeLongerThan('ab', MSG);
  expect(4.23223432434).toBeNear(4, 0.25, MSG);
  expect([null]).toBeNonEmptyArray(MSG);
  expect({ a: 1 }).toBeNonEmptyObject(MSG);
  expect(' ').toBeNonEmptyString(MSG);
  expect(1).toBeNumber(MSG);
  expect(new Object()).toBeObject(MSG);
  expect(1).toBeOddNumber(MSG);
  expect(new RegExp()).toBeRegExp(MSG);
  expect('ab').toBeSameLengthAs('ab', MSG);
  expect('ab').toBeShorterThan('abc', MSG);
  expect('').toBeString(MSG);
  expect(true).toBeTrue(MSG);
  expect(new Date()).toBeValidDate(MSG);
  expect(' ').toBeWhitespace(MSG);
  expect(1).toBeWholeNumber(MSG);
  expect(0).toBeWithinRange(0, 2, MSG);
});


/***/ }),

/***/ "./test/regExp.spec.js":
/*!*****************************!*\
  !*** ./test/regExp.spec.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const callSpy = __webpack_require__(/*! ./lib/callSpy */ "./test/lib/callSpy.js");

describe('any.regExp', () => {
  const shared = {};
  beforeEach(() => {
    shared.spy = callSpy(/abc/);
  });
  it('should confirm', () => {
    expect(shared.spy).toHaveBeenCalledWith(any.regExp());
  });
});


/***/ }),

/***/ "./test/sameLengthAs.spec.js":
/*!***********************************!*\
  !*** ./test/sameLengthAs.spec.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const callSpy = __webpack_require__(/*! ./lib/callSpy */ "./test/lib/callSpy.js");

describe('any.sameLengthAs', () => {
  const shared = {};
  beforeEach(() => {
    shared.spy = callSpy('Cat');
  });
  it('should confirm', () => {
    expect(shared.spy).toHaveBeenCalledWith(any.sameLengthAs('Dog'));
  });
});


/***/ }),

/***/ "./test/shorterThan.spec.js":
/*!**********************************!*\
  !*** ./test/shorterThan.spec.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const callSpy = __webpack_require__(/*! ./lib/callSpy */ "./test/lib/callSpy.js");

describe('any.shorterThan', () => {
  const shared = {};
  beforeEach(() => {
    shared.spy = callSpy('skeletor');
  });
  it('should confirm', () => {
    expect(shared.spy).toHaveBeenCalledWith(
      any.shorterThan('trogdor the burninator')
    );
  });
});


/***/ }),

/***/ "./test/startingWith.spec.js":
/*!***********************************!*\
  !*** ./test/startingWith.spec.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const callSpy = __webpack_require__(/*! ./lib/callSpy */ "./test/lib/callSpy.js");

describe('any.startingWith', () => {
  const shared = {};
  beforeEach(() => {
    shared.spy = callSpy('San Francisco');
  });
  it('should confirm', () => {
    expect(shared.spy).toHaveBeenCalledWith(any.startingWith('San'));
  });
});


/***/ }),

/***/ "./test/toBeAfter.spec.js":
/*!********************************!*\
  !*** ./test/toBeAfter.spec.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toBeAfter', () => {
  describe('when invoked', () => {
    describe('when value is a Date', () => {
      describe('when date occurs after another', () => {
        it('should confirm', () => {
          expect(new Date('2013-01-01T01:00:00.000Z')).toBeAfter(
            new Date('2013-01-01T00:00:00.000Z')
          );
        });
      });
      describe('when date does NOT occur after another', () => {
        it('should deny', () => {
          expect(new Date('2013-01-01T00:00:00.000Z')).not.toBeAfter(
            new Date('2013-01-01T01:00:00.000Z')
          );
        });
      });
    });
  });
});


/***/ }),

/***/ "./test/toBeArray.spec.js":
/*!********************************!*\
  !*** ./test/toBeArray.spec.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeWhenNotArray = __webpack_require__(/*! ./lib/describeWhenNotArray */ "./test/lib/describeWhenNotArray.js");

describe('toBeArray', () => {
  describe('when invoked', () => {
    describe('when subject is a true Array', () => {
      it('should confirm', () => {
        expect([]).toBeArray();
        expect(new Array()).toBeArray();
      });
    });
    describeWhenNotArray('toBeArray');
  });
});


/***/ }),

/***/ "./test/toBeArrayOfBooleans.spec.js":
/*!******************************************!*\
  !*** ./test/toBeArrayOfBooleans.spec.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToBeArrayOfX = __webpack_require__(/*! ./lib/describeToBeArrayOfX */ "./test/lib/describeToBeArrayOfX.js");

describe('toBeArrayOfBooleans', () => {
  describeToBeArrayOfX('toBeArrayOfBooleans', {
    type: 'Boolean',
    whenValid() {
      expect([true]).toBeArrayOfBooleans();
      expect([new Boolean(true)]).toBeArrayOfBooleans();
      expect([new Boolean(false)]).toBeArrayOfBooleans();
      expect([false, true]).toBeArrayOfBooleans();
    },
    whenInvalid() {
      expect([null]).not.toBeArrayOfBooleans();
    },
    whenMixed() {
      expect([null, false]).not.toBeArrayOfBooleans();
      expect([null, true]).not.toBeArrayOfBooleans();
    }
  });
});


/***/ }),

/***/ "./test/toBeArrayOfNumbers.spec.js":
/*!*****************************************!*\
  !*** ./test/toBeArrayOfNumbers.spec.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToBeArrayOfX = __webpack_require__(/*! ./lib/describeToBeArrayOfX */ "./test/lib/describeToBeArrayOfX.js");

describe('toBeArrayOfNumbers', () => {
  describeToBeArrayOfX('toBeArrayOfNumbers', {
    type: 'Number',
    whenValid() {
      expect([1]).toBeArrayOfNumbers();
      expect([new Number(1)]).toBeArrayOfNumbers();
      expect([new Number(0)]).toBeArrayOfNumbers();
      expect([0, 1]).toBeArrayOfNumbers();
    },
    whenInvalid() {
      expect([null]).not.toBeArrayOfNumbers();
    },
    whenMixed() {
      expect([null, 0]).not.toBeArrayOfNumbers();
    }
  });
});


/***/ }),

/***/ "./test/toBeArrayOfObjects.spec.js":
/*!*****************************************!*\
  !*** ./test/toBeArrayOfObjects.spec.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToBeArrayOfX = __webpack_require__(/*! ./lib/describeToBeArrayOfX */ "./test/lib/describeToBeArrayOfX.js");

describe('toBeArrayOfObjects', () => {
  describeToBeArrayOfX('toBeArrayOfObjects', {
    type: 'Object',
    whenValid() {
      expect([{}, {}]).toBeArrayOfObjects();
    },
    whenInvalid() {
      expect([null]).not.toBeArrayOfObjects();
      expect(['Object']).not.toBeArrayOfObjects();
      expect(['[object Object]']).not.toBeArrayOfObjects();
    },
    whenMixed() {
      expect([null, {}]).not.toBeArrayOfObjects();
    }
  });
});


/***/ }),

/***/ "./test/toBeArrayOfSize.spec.js":
/*!**************************************!*\
  !*** ./test/toBeArrayOfSize.spec.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeWhenNotArray = __webpack_require__(/*! ./lib/describeWhenNotArray */ "./test/lib/describeWhenNotArray.js");

describe('toBeArrayOfSize', () => {
  describe('when invoked', () => {
    describe('when subject is a true Array', () => {
      describe('when subject has the expected number of members', () => {
        it('should confirm', () => {
          let _undefined;
          expect([]).toBeArrayOfSize(0);
          expect([null]).toBeArrayOfSize(1);
          expect([false, false]).toBeArrayOfSize(2);
          expect([_undefined, _undefined]).toBeArrayOfSize(2);
        });
      });
      describe('when subject has an unexpected number of members', () => {
        it('should deny', () => {
          expect([]).not.toBeArrayOfSize(1);
          expect([null]).not.toBeArrayOfSize(0);
          expect([true, true]).not.toBeArrayOfSize(1);
        });
      });
    });
    describeWhenNotArray('toBeArrayOfSize');
  });
});


/***/ }),

/***/ "./test/toBeArrayOfStrings.spec.js":
/*!*****************************************!*\
  !*** ./test/toBeArrayOfStrings.spec.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToBeArrayOfX = __webpack_require__(/*! ./lib/describeToBeArrayOfX */ "./test/lib/describeToBeArrayOfX.js");

describe('toBeArrayOfStrings', () => {
  describeToBeArrayOfX('toBeArrayOfStrings', {
    type: 'String',
    whenValid() {
      expect(['truthy']).toBeArrayOfStrings();
      expect([new String('truthy')]).toBeArrayOfStrings();
      expect([new String('')]).toBeArrayOfStrings();
      expect(['', 'truthy']).toBeArrayOfStrings();
    },
    whenInvalid() {
      expect([null]).not.toBeArrayOfStrings();
    },
    whenMixed() {
      expect([null, '']).not.toBeArrayOfStrings();
    }
  });
});


/***/ }),

/***/ "./test/toBeBefore.spec.js":
/*!*********************************!*\
  !*** ./test/toBeBefore.spec.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toBeBefore', () => {
  describe('when invoked', () => {
    describe('when value is a Date', () => {
      describe('when date occurs before another', () => {
        it('should confirm', () => {
          expect(new Date('2013-01-01T00:00:00.000Z')).toBeBefore(
            new Date('2013-01-01T01:00:00.000Z')
          );
        });
      });
      describe('when date does NOT occur before another', () => {
        it('should deny', () => {
          expect(new Date('2013-01-01T01:00:00.000Z')).not.toBeBefore(
            new Date('2013-01-01T00:00:00.000Z')
          );
        });
      });
    });
  });
});


/***/ }),

/***/ "./test/toBeBoolean.spec.js":
/*!**********************************!*\
  !*** ./test/toBeBoolean.spec.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toBeBoolean', () => {
  describe('when invoked', () => {
    describe('when subject not only truthy or falsy, but a boolean', () => {
      it('should confirm', () => {
        expect(true).toBeBoolean();
        expect(false).toBeBoolean();
        expect(new Boolean(true)).toBeBoolean();
        expect(new Boolean(false)).toBeBoolean();
      });
    });
    describe('when subject is truthy or falsy', () => {
      it('should deny', () => {
        expect(1).not.toBeBoolean();
        expect(0).not.toBeBoolean();
      });
    });
  });
});


/***/ }),

/***/ "./test/toBeCalculable.spec.js":
/*!*************************************!*\
  !*** ./test/toBeCalculable.spec.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toBeCalculable', () => {
  describe('when invoked', () => {
    describe('when subject CAN be coerced to be used in mathematical operations', () => {
      it('should confirm', () => {
        expect('1').toBeCalculable();
        expect('').toBeCalculable();
        expect(null).toBeCalculable();
      });
    });
    describe('when subject can NOT be coerced by JavaScript to be used in mathematical operations', () => {
      it('should deny', () => {
        expect({}).not.toBeCalculable();
        expect(NaN).not.toBeCalculable();
      });
    });
  });
});


/***/ }),

/***/ "./test/toBeDate.spec.js":
/*!*******************************!*\
  !*** ./test/toBeDate.spec.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toBeDate', () => {
  describe('when invoked', () => {
    describe('when value is an instance of Date', () => {
      it('should confirm', () => {
        expect(new Date()).toBeDate();
      });
    });
    describe('when value is NOT an instance of Date', () => {
      it('should deny', () => {
        expect(null).not.toBeDate();
      });
    });
  });
});


/***/ }),

/***/ "./test/toBeEmptyArray.spec.js":
/*!*************************************!*\
  !*** ./test/toBeEmptyArray.spec.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeWhenNotArray = __webpack_require__(/*! ./lib/describeWhenNotArray */ "./test/lib/describeWhenNotArray.js");

describe('toBeEmptyArray', () => {
  describe('when invoked', () => {
    describe('when subject is a true Array', () => {
      describe('when subject has members', () => {
        it('should confirm', () => {
          expect([]).toBeEmptyArray();
        });
      });
      describe('when subject has no members', () => {
        it('should deny', () => {
          expect([null]).not.toBeEmptyArray();
          expect(['']).not.toBeEmptyArray();
          expect([1]).not.toBeEmptyArray();
          expect([true]).not.toBeEmptyArray();
          expect([false]).not.toBeEmptyArray();
        });
      });
    });
    describeWhenNotArray('toBeEmptyArray');
  });
});


/***/ }),

/***/ "./test/toBeEmptyObject.spec.js":
/*!**************************************!*\
  !*** ./test/toBeEmptyObject.spec.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toBeEmptyObject', () => {
  let Foo;
  beforeEach(() => {
    Foo = function() {};
  });
  describe('when invoked', () => {
    describe('when subject IS an Object with no instance members', () => {
      beforeEach(() => {
        Foo.prototype = {
          b: 2
        };
      });
      it('should confirm', () => {
        expect(new Foo()).toBeEmptyObject();
        expect({}).toBeEmptyObject();
      });
    });
    describe('when subject is NOT an Object with no instance members', () => {
      it('should deny', () => {
        expect({
          a: 1
        }).not.toBeEmptyObject();
        expect(null).not.toBeNonEmptyObject();
      });
    });
  });
});


/***/ }),

/***/ "./test/toBeEmptyString.spec.js":
/*!**************************************!*\
  !*** ./test/toBeEmptyString.spec.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toBeEmptyString', () => {
  describe('when invoked', () => {
    describe('when subject IS a string with no characters', () => {
      it('should confirm', () => {
        expect('').toBeEmptyString();
      });
    });
    describe('when subject is NOT a string with no characters', () => {
      it('should deny', () => {
        expect(' ').not.toBeEmptyString();
      });
    });
  });
});


/***/ }),

/***/ "./test/toBeEvenNumber.spec.js":
/*!*************************************!*\
  !*** ./test/toBeEvenNumber.spec.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toBeEvenNumber', () => {
  describe('when invoked', () => {
    describe('when subject IS an even number', () => {
      it('should confirm', () => {
        expect(2).toBeEvenNumber();
      });
    });
    describe('when subject is NOT an even number', () => {
      it('should deny', () => {
        expect(1).not.toBeEvenNumber();
        expect(NaN).not.toBeEvenNumber();
      });
    });
  });
});


/***/ }),

/***/ "./test/toBeFalse.spec.js":
/*!********************************!*\
  !*** ./test/toBeFalse.spec.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toBeFalse', () => {
  describe('when invoked', () => {
    describe('when subject is not only falsy, but a boolean false', () => {
      it('should confirm', () => {
        expect(false).toBeFalse();
        expect(new Boolean(false)).toBeFalse();
      });
    });
    describe('when subject is falsy', () => {
      it('should deny', () => {
        expect(1).not.toBeFalse();
      });
    });
  });
});


/***/ }),

/***/ "./test/toBeFunction.spec.js":
/*!***********************************!*\
  !*** ./test/toBeFunction.spec.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toBeFunction', () => {
  describe('when invoked', () => {
    describe('when subject IS a function', () => {
      it('should confirm', () => {
        expect(() => {}).toBeFunction();
      });
    });
    describe('when subject is NOT a function', () => {
      it('should deny', () => {
        expect(/regexp/).not.toBeFunction();
      });
    });
  });
});


/***/ }),

/***/ "./test/toBeGreaterThanOrEqualTo.spec.js":
/*!***********************************************!*\
  !*** ./test/toBeGreaterThanOrEqualTo.spec.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toBeGreaterThanOrEqualTo', () => {
  it('asserts value is greater or equal than a given number', () => {
    expect(2).toBeGreaterThanOrEqualTo(1);
    expect(1).toBeGreaterThanOrEqualTo(-1);
    expect(-1).toBeGreaterThanOrEqualTo(-2);
    expect(-2).toBeGreaterThanOrEqualTo(-2);
    expect(NaN).not.toBeGreaterThanOrEqualTo(0);
    expect(1).not.toBeGreaterThanOrEqualTo(2);
    expect(-1).not.toBeGreaterThanOrEqualTo(0);
  });
});


/***/ }),

/***/ "./test/toBeHtmlString.spec.js":
/*!*************************************!*\
  !*** ./test/toBeHtmlString.spec.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toBeHtmlString', () => {
  describe('when invoked', () => {
    describe('when subject IS a string of HTML markup', () => {
      let ngMultiLine;
      beforeEach(() => {
        ngMultiLine = '';
        ngMultiLine +=
          '<a data-ng-href="//www.google.com" data-ng-click="launchApp($event)" target="_blank" class="ng-binding" href="//www.google.com">';
        ngMultiLine += '\n';
        ngMultiLine += '  Watch with Google TV';
        ngMultiLine += '\n';
        ngMultiLine += '</a>';
        ngMultiLine += '\n';
      });
      it('should confirm', () => {
        expect('<element>text</element>').toBeHtmlString();
        expect(
          '<a data-ng-href="//foo.com" data-ng-click="bar($event)">baz</a>'
        ).toBeHtmlString();
        expect(
          '<div ng-if="foo > bar || bar < foo && baz == bar"></div>'
        ).toBeHtmlString();
        expect(
          '<li ng-if="foo > bar || bar < foo && baz == bar">'
        ).toBeHtmlString();
        expect(ngMultiLine).toBeHtmlString();
      });
    });
    describe('when subject is NOT a string of HTML markup', () => {
      it('should deny', () => {
        expect('div').not.toBeHtmlString();
        expect(null).not.toBeHtmlString();
      });
    });
  });
});


/***/ }),

/***/ "./test/toBeIso8601.spec.js":
/*!**********************************!*\
  !*** ./test/toBeIso8601.spec.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toBeIso8601', () => {
  describe('when invoked', () => {
    describe('when value is a Date String conforming to the ISO 8601 standard', () => {
      describe('when specified date is valid', () => {
        it('should confirm', () => {
          expect('2013-07-08T07:29:15.863Z').toBeIso8601();
          expect('2013-07-08T07:29:15.863').toBeIso8601();
          expect('2013-07-08T07:29:15').toBeIso8601();
          expect('2013-07-08T07:29').toBeIso8601();
          expect('2013-07-08').toBeIso8601();
        });
      });
      describe('when specified date is NOT valid', () => {
        it('should deny', () => {
          expect('2013-99-12T00:00:00.000Z').not.toBeIso8601();
          expect('2013-12-99T00:00:00.000Z').not.toBeIso8601();
          expect('2013-01-01T99:00:00.000Z').not.toBeIso8601();
          expect('2013-01-01T99:99:00.000Z').not.toBeIso8601();
          expect('2013-01-01T00:00:99.000Z').not.toBeIso8601();
        });
      });
    });
    describe('when value is a String NOT conforming to the ISO 8601 standard', () => {
      it('should deny', () => {
        expect('2013-07-08T07:29:15.').not.toBeIso8601();
        expect('2013-07-08T07:29:').not.toBeIso8601();
        expect('2013-07-08T07:2').not.toBeIso8601();
        expect('2013-07-08T07:').not.toBeIso8601();
        expect('2013-07-08T07').not.toBeIso8601();
        expect('2013-07-08T').not.toBeIso8601();
        expect('2013-07-0').not.toBeIso8601();
        expect('2013-07-').not.toBeIso8601();
        expect('2013-07').not.toBeIso8601();
        expect('2013-0').not.toBeIso8601();
        expect('2013-').not.toBeIso8601();
        expect('2013').not.toBeIso8601();
        expect('201').not.toBeIso8601();
        expect('20').not.toBeIso8601();
        expect('2').not.toBeIso8601();
        expect('').not.toBeIso8601();
      });
    });
  });
});


/***/ }),

/***/ "./test/toBeJsonString.spec.js":
/*!*************************************!*\
  !*** ./test/toBeJsonString.spec.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toBeJsonString', () => {
  describe('when invoked', () => {
    describe('when subject IS a string of parseable JSON', () => {
      it('should confirm', () => {
        expect('{}').toBeJsonString();
        expect('[]').toBeJsonString();
        expect('[1]').toBeJsonString();
      });
    });
    describe('when subject is NOT a string of parseable JSON', () => {
      it('should deny', () => {
        let _undefined;
        expect('[1,]').not.toBeJsonString();
        expect('<>').not.toBeJsonString();
        expect(null).not.toBeJsonString();
        expect('').not.toBeJsonString();
        expect(_undefined).not.toBeJsonString();
      });
    });
  });
});


/***/ }),

/***/ "./test/toBeLessThanOrEqualTo.spec.js":
/*!********************************************!*\
  !*** ./test/toBeLessThanOrEqualTo.spec.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toBeLessThanOrEqualTo', () => {
  it('asserts value is less or equal than a given number', () => {
    expect(1).toBeLessThanOrEqualTo(2);
    expect(-1).toBeLessThanOrEqualTo(1);
    expect(-2).toBeLessThanOrEqualTo(-1);
    expect(-2).toBeLessThanOrEqualTo(-2);
    expect(NaN).not.toBeLessThanOrEqualTo(0);
    expect(2).not.toBeLessThanOrEqualTo(1);
    expect(0).not.toBeLessThanOrEqualTo(-1);
  });
});


/***/ }),

/***/ "./test/toBeLongerThan.spec.js":
/*!*************************************!*\
  !*** ./test/toBeLongerThan.spec.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toBeLongerThan', () => {
  describe('when invoked', () => {
    describe('when the subject and comparison ARE both strings', () => {
      describe('when the subject IS longer than the comparision string', () => {
        it('should confirm', () => {
          expect('abc').toBeLongerThan('ab');
          expect('a').toBeLongerThan('');
        });
      });
      describe('when the subject is NOT longer than the comparision string', () => {
        it('should deny', () => {
          expect('ab').not.toBeLongerThan('abc');
          expect('').not.toBeLongerThan('a');
        });
      });
    });
    describe('when the subject and comparison are NOT both strings', () => {
      it('should deny (we are asserting the relative lengths of two strings)', () => {
        let _undefined;
        expect('truthy').not.toBeLongerThan(_undefined);
        expect(_undefined).not.toBeLongerThan('truthy');
        expect('').not.toBeLongerThan(_undefined);
        expect(_undefined).not.toBeLongerThan('');
      });
    });
  });
});


/***/ }),

/***/ "./test/toBeNear.spec.js":
/*!*******************************!*\
  !*** ./test/toBeNear.spec.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toBeNear', () => {
  describe('when invoked', () => {
    describe('when subject IS a number >= number-epsilon and <= number+epsilon', () => {
      it('should confirm', () => {
        expect(4.23223432434).toBeNear(4, 0.25);
        expect(22).toBeNear(20, 2);
        expect(-42).toBeNear(-40, 2);
      });
    });
    describe('when subject is NOT a number >= number-epsilon and <= number+epsilon', () => {
      it('should deny', () => {
        expect(NaN).not.toBeNear(42, 2);
        expect(4.23223432434).not.toBeNear(4, 0.2);
        expect(22).not.toBeNear(20, 1);
        expect(-42).not.toBeNear(-18, 11);
      });
    });
  });
});


/***/ }),

/***/ "./test/toBeNonEmptyArray.spec.js":
/*!****************************************!*\
  !*** ./test/toBeNonEmptyArray.spec.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeWhenNotArray = __webpack_require__(/*! ./lib/describeWhenNotArray */ "./test/lib/describeWhenNotArray.js");

describe('toBeNonEmptyArray', () => {
  describe('when invoked', () => {
    describe('when subject is a true Array', () => {
      describe('when subject has members', () => {
        it('should confirm', () => {
          let _undefined;
          expect([null]).toBeNonEmptyArray();
          expect([_undefined]).toBeNonEmptyArray();
          expect(['']).toBeNonEmptyArray();
        });
      });
      describe('when subject has no members', () => {
        it('should deny', () => {
          expect([]).not.toBeNonEmptyArray();
        });
      });
    });
    describeWhenNotArray('toBeNonEmptyArray');
  });
});


/***/ }),

/***/ "./test/toBeNonEmptyObject.spec.js":
/*!*****************************************!*\
  !*** ./test/toBeNonEmptyObject.spec.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toBeNonEmptyObject', () => {
  let Foo;
  beforeEach(() => {
    Foo = function() {};
  });
  describe('when invoked', () => {
    describe('when subject IS an Object with at least one instance member', () => {
      it('should confirm', () => {
        expect({
          a: 1
        }).toBeNonEmptyObject();
      });
    });
    describe('when subject is NOT an Object with at least one instance member', () => {
      beforeEach(() => {
        Foo.prototype = {
          b: 2
        };
      });
      it('should deny', () => {
        expect(new Foo()).not.toBeNonEmptyObject();
        expect({}).not.toBeNonEmptyObject();
        expect(null).not.toBeNonEmptyObject();
      });
    });
  });
});


/***/ }),

/***/ "./test/toBeNonEmptyString.spec.js":
/*!*****************************************!*\
  !*** ./test/toBeNonEmptyString.spec.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toBeNonEmptyString', () => {
  describe('when invoked', () => {
    describe('when subject IS a string with at least one character', () => {
      it('should confirm', () => {
        expect(' ').toBeNonEmptyString();
      });
    });
    describe('when subject is NOT a string with at least one character', () => {
      it('should deny', () => {
        expect('').not.toBeNonEmptyString();
        expect(null).not.toBeNonEmptyString();
      });
    });
  });
});


/***/ }),

/***/ "./test/toBeNumber.spec.js":
/*!*********************************!*\
  !*** ./test/toBeNumber.spec.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toBeNumber', () => {
  describe('when invoked', () => {
    describe('when subject IS a number', () => {
      it('should confirm', () => {
        expect(1).toBeNumber();
        expect(1.11).toBeNumber();
        expect(1e3).toBeNumber();
        expect(0.11).toBeNumber();
        expect(-11).toBeNumber();
      });
    });
    describe('when subject is NOT a number', () => {
      it('should deny', () => {
        expect('1').not.toBeNumber();
        expect(NaN).not.toBeNumber();
      });
    });
  });
});


/***/ }),

/***/ "./test/toBeObject.spec.js":
/*!*********************************!*\
  !*** ./test/toBeObject.spec.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toBeObject', () => {
  let Foo;
  beforeEach(() => {
    Foo = function() {};
  });
  describe('when invoked', () => {
    describe('when subject IS an Object', () => {
      it('should confirm', () => {
        expect(new Object()).toBeObject();
        expect(new Foo()).toBeObject();
        expect({}).toBeObject();
      });
    });
    describe('when subject is NOT an Object', () => {
      it('should deny', () => {
        expect(null).not.toBeObject();
        expect(123).not.toBeObject();
        expect('[object Object]').not.toBeObject();
      });
    });
  });
});


/***/ }),

/***/ "./test/toBeOddNumber.spec.js":
/*!************************************!*\
  !*** ./test/toBeOddNumber.spec.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toBeOddNumber', () => {
  describe('when invoked', () => {
    describe('when subject IS an odd number', () => {
      it('should confirm', () => {
        expect(1).toBeOddNumber();
      });
    });
    describe('when subject is NOT an odd number', () => {
      it('should deny', () => {
        expect(2).not.toBeOddNumber();
        expect(NaN).not.toBeOddNumber();
      });
    });
  });
});


/***/ }),

/***/ "./test/toBeRegExp.spec.js":
/*!*********************************!*\
  !*** ./test/toBeRegExp.spec.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toBeRegExp', () => {
  describe('when invoked', () => {
    describe('when value is an instance of RegExp', () => {
      it('should confirm', () => {
        expect(new RegExp()).toBeRegExp();
        expect(/abc/).toBeRegExp();
      });
    });
    describe('when value is not an instance of RegExp', () => {
      it('should deny', () => {
        expect(null).not.toBeRegExp();
        expect(() => {}).not.toBeRegExp();
        expect('abc').not.toBeRegExp();
      });
    });
  });
});


/***/ }),

/***/ "./test/toBeSameLengthAs.spec.js":
/*!***************************************!*\
  !*** ./test/toBeSameLengthAs.spec.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toBeSameLengthAs', () => {
  describe('when invoked', () => {
    describe('when the subject and comparison ARE both strings', () => {
      describe('when the subject IS the same length as the comparision string', () => {
        it('should confirm', () => {
          expect('ab').toBeSameLengthAs('ab');
        });
      });
      describe('when the subject is NOT the same length as the comparision string', () => {
        it('should deny', () => {
          expect('abc').not.toBeSameLengthAs('ab');
          expect('a').not.toBeSameLengthAs('');
          expect('').not.toBeSameLengthAs('a');
        });
      });
    });
    describe('when the subject and comparison are NOT both strings', () => {
      it('should deny (we are asserting the relative lengths of two strings)', () => {
        let _undefined;
        expect('truthy').not.toBeSameLengthAs(_undefined);
        expect(_undefined).not.toBeSameLengthAs('truthy');
        expect('').not.toBeSameLengthAs(_undefined);
        expect(_undefined).not.toBeSameLengthAs('');
      });
    });
  });
});


/***/ }),

/***/ "./test/toBeShorterThan.spec.js":
/*!**************************************!*\
  !*** ./test/toBeShorterThan.spec.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toBeShorterThan', () => {
  describe('when invoked', () => {
    describe('when the subject and comparison ARE both strings', () => {
      describe('when the subject IS shorter than the comparision string', () => {
        it('should confirm', () => {
          expect('ab').toBeShorterThan('abc');
          expect('').toBeShorterThan('a');
        });
      });
      describe('when the subject is NOT shorter than the comparision string', () => {
        it('should deny', () => {
          expect('abc').not.toBeShorterThan('ab');
          expect('a').not.toBeShorterThan('');
        });
      });
    });
    describe('when the subject and comparison are NOT both strings', () => {
      it('should deny (we are asserting the relative lengths of two strings)', () => {
        let _undefined;
        expect('truthy').not.toBeShorterThan(_undefined);
        expect(_undefined).not.toBeShorterThan('truthy');
        expect('').not.toBeShorterThan(_undefined);
        expect(_undefined).not.toBeShorterThan('');
      });
    });
  });
});


/***/ }),

/***/ "./test/toBeString.spec.js":
/*!*********************************!*\
  !*** ./test/toBeString.spec.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toBeString', () => {
  describe('when invoked', () => {
    describe('when subject IS a string of any length', () => {
      it('should confirm', () => {
        expect('').toBeString();
        expect(' ').toBeString();
      });
    });
    describe('when subject is NOT a string of any length', () => {
      it('should deny', () => {
        expect(null).not.toBeString();
      });
    });
  });
});


/***/ }),

/***/ "./test/toBeTrue.spec.js":
/*!*******************************!*\
  !*** ./test/toBeTrue.spec.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toBeTrue', () => {
  describe('when invoked', () => {
    describe('when subject is not only truthy, but a boolean true', () => {
      it('should confirm', () => {
        expect(true).toBeTrue();
        expect(new Boolean(true)).toBeTrue();
      });
    });
    describe('when subject is truthy', () => {
      it('should deny', () => {
        expect(1).not.toBeTrue();
      });
    });
  });
});


/***/ }),

/***/ "./test/toBeValidDate.spec.js":
/*!************************************!*\
  !*** ./test/toBeValidDate.spec.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toBeValidDate', () => {
  describe('when invoked', () => {
    describe('when value is a valid instance of Date', () => {
      it('should confirm', () => {
        expect(new Date()).toBeValidDate();
        expect(new Date('November 18, 1985 08:22:00')).toBeValidDate();
        expect(new Date('1985-11-18T08:22:00')).toBeValidDate();
        expect(new Date(1985, 11, 18, 8, 22, 0)).toBeValidDate();
      });
    });
    describe('when value is NOT a valid instance of Date', () => {
      it('should deny', () => {
        expect(null).not.toBeValidDate();
        expect(() => {}).not.toBeValidDate();
        try {
          expect(new Date('')).not.toBeValidDate();
          expect(new Date('invalid')).not.toBeValidDate();
        } catch (err) {
          // ignore "RangeError: Invalid time value" seen only in node.js
        }
      });
    });
  });
});


/***/ }),

/***/ "./test/toBeWhitespace.spec.js":
/*!*************************************!*\
  !*** ./test/toBeWhitespace.spec.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toBeWhitespace', () => {
  describe('when invoked', () => {
    describe('when subject IS a string containing only tabs, spaces, returns etc', () => {
      it('should confirm', () => {
        expect(' ').toBeWhitespace();
        expect('').toBeWhitespace();
      });
    });
    describe('when subject is NOT a string containing only tabs, spaces, returns etc', () => {
      it('should deny', () => {
        expect('has-no-whitespace').not.toBeWhitespace();
        expect('has whitespace').not.toBeWhitespace();
        expect(null).not.toBeWhitespace();
      });
    });
  });
});


/***/ }),

/***/ "./test/toBeWholeNumber.spec.js":
/*!**************************************!*\
  !*** ./test/toBeWholeNumber.spec.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toBeWholeNumber', () => {
  describe('when invoked', () => {
    describe('when subject IS a number with no positive decimal places', () => {
      it('should confirm', () => {
        expect(1).toBeWholeNumber();
        expect(0).toBeWholeNumber();
        expect(0.0).toBeWholeNumber();
      });
    });
    describe('when subject is NOT a number with no positive decimal places', () => {
      it('should deny', () => {
        expect(NaN).not.toBeWholeNumber();
        expect(1.1).not.toBeWholeNumber();
        expect(0.1).not.toBeWholeNumber();
      });
    });
  });
});


/***/ }),

/***/ "./test/toBeWithinRange.spec.js":
/*!**************************************!*\
  !*** ./test/toBeWithinRange.spec.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toBeWithinRange', () => {
  describe('when invoked', () => {
    describe('when subject IS a number >= floor and <= ceiling', () => {
      it('should confirm', () => {
        expect(0).toBeWithinRange(0, 2);
        expect(1).toBeWithinRange(0, 2);
        expect(2).toBeWithinRange(0, 2);
      });
    });
    describe('when subject is NOT a number >= floor and <= ceiling', () => {
      it('should deny', () => {
        expect(-3).not.toBeWithinRange(0, 2);
        expect(-2).not.toBeWithinRange(0, 2);
        expect(-1).not.toBeWithinRange(0, 2);
        expect(3).not.toBeWithinRange(0, 2);
        expect(NaN).not.toBeWithinRange(0, 2);
      });
    });
  });
});


/***/ }),

/***/ "./test/toEndWith.spec.js":
/*!********************************!*\
  !*** ./test/toEndWith.spec.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toEndWith', () => {
  describe('when invoked', () => {
    describe('when subject is NOT an undefined or empty string', () => {
      describe('when subject is a string whose trailing characters match the expected string', () => {
        it('should confirm', () => {
          expect('jamie').toEndWith('mie');
        });
      });
      describe('when subject is a string whose trailing characters DO NOT match the expected string', () => {
        it('should deny', () => {
          expect('jamie ').not.toEndWith('mie');
          expect('jamiE').not.toEndWith('mie');
        });
      });
    });
    describe('when subject IS an undefined or empty string', () => {
      it('should deny', () => {
        let _undefined;
        expect('').not.toEndWith('');
        expect(_undefined).not.toEndWith('');
        expect(_undefined).not.toEndWith('undefined');
        expect('undefined').not.toEndWith(_undefined);
      });
    });
  });
});


/***/ }),

/***/ "./test/toHaveArray.spec.js":
/*!**********************************!*\
  !*** ./test/toHaveArray.spec.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveArrayX = __webpack_require__(/*! ./lib/describeToHaveArrayX */ "./test/lib/describeToHaveArrayX.js");

describe('toHaveArray', () => {
  describeToHaveArrayX('toHaveArray', () => {
    it('should confirm', () => {
      expect({
        memberName: []
      }).toHaveArray('memberName');
      expect({
        memberName: [1, 2, 3]
      }).toHaveArray('memberName');
    });
  });
});


/***/ }),

/***/ "./test/toHaveArrayOfBooleans.spec.js":
/*!********************************************!*\
  !*** ./test/toHaveArrayOfBooleans.spec.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveArrayX = __webpack_require__(/*! ./lib/describeToHaveArrayX */ "./test/lib/describeToHaveArrayX.js");

describe('toHaveArrayOfBooleans', () => {
  describeToHaveArrayX('toHaveArrayOfBooleans', () => {
    describe('when named Array is empty', () => {
      it('should confirm', () => {
        expect({
          memberName: []
        }).toHaveArrayOfBooleans('memberName');
      });
    });
    describe('when named Array has items', () => {
      describe('when all items are booleans', () => {
        it('should confirm', () => {
          expect({
            memberName: [true]
          }).toHaveArrayOfBooleans('memberName');
          expect({
            memberName: [new Boolean(true)]
          }).toHaveArrayOfBooleans('memberName');
          expect({
            memberName: [new Boolean(false)]
          }).toHaveArrayOfBooleans('memberName');
          expect({
            memberName: [false, true]
          }).toHaveArrayOfBooleans('memberName');
        });
      });
      describe('when any item is not a boolean', () => {
        it('should deny', () => {
          expect({
            memberName: [null]
          }).not.toHaveArrayOfBooleans('memberName');
          expect({
            memberName: [null, false]
          }).not.toHaveArrayOfBooleans('memberName');
        });
      });
    });
  });
});


/***/ }),

/***/ "./test/toHaveArrayOfNumbers.spec.js":
/*!*******************************************!*\
  !*** ./test/toHaveArrayOfNumbers.spec.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveArrayX = __webpack_require__(/*! ./lib/describeToHaveArrayX */ "./test/lib/describeToHaveArrayX.js");

describe('toHaveArrayOfNumbers', () => {
  describeToHaveArrayX('toHaveArrayOfNumbers', () => {
    describe('when named Array is empty', () => {
      it('should confirm', () => {
        expect({
          memberName: []
        }).toHaveArrayOfNumbers('memberName');
      });
    });
    describe('when named Array has items', () => {
      describe('when all items are numbers', () => {
        it('should confirm', () => {
          expect({
            memberName: [1]
          }).toHaveArrayOfNumbers('memberName');
          expect({
            memberName: [new Number(1)]
          }).toHaveArrayOfNumbers('memberName');
          expect({
            memberName: [new Number(0)]
          }).toHaveArrayOfNumbers('memberName');
          expect({
            memberName: [0, 1]
          }).toHaveArrayOfNumbers('memberName');
        });
      });
      describe('when any item is not a number', () => {
        it('should deny', () => {
          expect({
            memberName: [null]
          }).not.toHaveArrayOfNumbers('memberName');
          expect({
            memberName: [null, 0]
          }).not.toHaveArrayOfNumbers('memberName');
        });
      });
    });
  });
});


/***/ }),

/***/ "./test/toHaveArrayOfObjects.spec.js":
/*!*******************************************!*\
  !*** ./test/toHaveArrayOfObjects.spec.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveArrayX = __webpack_require__(/*! ./lib/describeToHaveArrayX */ "./test/lib/describeToHaveArrayX.js");

describe('toHaveArrayOfObjects', () => {
  describeToHaveArrayX('toHaveArrayOfObjects', () => {
    describe('when named Array is empty', () => {
      it('should confirm', () => {
        expect({
          memberName: []
        }).toHaveArrayOfObjects('memberName');
      });
    });
    describe('when named Array has items', () => {
      describe('when all items are objects', () => {
        it('should confirm', () => {
          expect({
            memberName: [{}]
          }).toHaveArrayOfObjects('memberName');
          expect({
            memberName: [{}, {}]
          }).toHaveArrayOfObjects('memberName');
        });
      });
      describe('when any item is not an object', () => {
        it('should deny', () => {
          expect({
            memberName: [null]
          }).not.toHaveArrayOfObjects('memberName');
          expect({
            memberName: [null, {}]
          }).not.toHaveArrayOfObjects('memberName');
        });
      });
    });
  });
});


/***/ }),

/***/ "./test/toHaveArrayOfSize.spec.js":
/*!****************************************!*\
  !*** ./test/toHaveArrayOfSize.spec.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveArrayX = __webpack_require__(/*! ./lib/describeToHaveArrayX */ "./test/lib/describeToHaveArrayX.js");

describe('toHaveArrayOfSize', () => {
  describeToHaveArrayX('toHaveArrayOfSize', () => {
    describe('when number of expected items does not match', () => {
      it('should deny', () => {
        expect({
          memberName: ''
        }).not.toHaveArrayOfSize('memberName');
        expect({
          memberName: ['bar']
        }).not.toHaveArrayOfSize('memberName', 0);
      });
    });
    describe('when number of expected items does match', () => {
      it('should confirm', () => {
        expect({
          memberName: []
        }).toHaveArrayOfSize('memberName', 0);
        expect({
          memberName: ['bar']
        }).toHaveArrayOfSize('memberName', 1);
        expect({
          memberName: ['bar', 'baz']
        }).toHaveArrayOfSize('memberName', 2);
      });
    });
  });
});


/***/ }),

/***/ "./test/toHaveArrayOfStrings.spec.js":
/*!*******************************************!*\
  !*** ./test/toHaveArrayOfStrings.spec.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveArrayX = __webpack_require__(/*! ./lib/describeToHaveArrayX */ "./test/lib/describeToHaveArrayX.js");

describe('toHaveArrayOfStrings', () => {
  describeToHaveArrayX('toHaveArrayOfStrings', () => {
    describe('when named Array is empty', () => {
      it('should confirm', () => {
        expect({
          memberName: []
        }).toHaveArrayOfStrings('memberName');
      });
    });
    describe('when named Array has items', () => {
      describe('when all items are strings', () => {
        it('should confirm', () => {
          expect({
            memberName: ['truthy']
          }).toHaveArrayOfStrings('memberName');
          expect({
            memberName: [new String('truthy')]
          }).toHaveArrayOfStrings('memberName');
          expect({
            memberName: [new String('')]
          }).toHaveArrayOfStrings('memberName');
          expect({
            memberName: ['', 'truthy']
          }).toHaveArrayOfStrings('memberName');
        });
      });
      describe('when any item is not a string', () => {
        it('should deny', () => {
          expect({
            memberName: [null]
          }).not.toHaveArrayOfStrings('memberName');
          expect({
            memberName: [null, '']
          }).not.toHaveArrayOfStrings('memberName');
        });
      });
    });
  });
});


/***/ }),

/***/ "./test/toHaveBoolean.spec.js":
/*!************************************!*\
  !*** ./test/toHaveBoolean.spec.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveBooleanX = __webpack_require__(/*! ./lib/describeToHaveBooleanX */ "./test/lib/describeToHaveBooleanX.js");

describe('toHaveBoolean', () => {
  describeToHaveBooleanX('toHaveBoolean', () => {
    describe('when primitive', () => {
      it('should confirm', () => {
        expect({
          memberName: true
        }).toHaveBoolean('memberName');
        expect({
          memberName: false
        }).toHaveBoolean('memberName');
      });
    });
    describe('when Boolean object', () => {
      it('should confirm', () => {
        expect({
          memberName: new Boolean(true)
        }).toHaveBoolean('memberName');
        expect({
          memberName: new Boolean(false)
        }).toHaveBoolean('memberName');
      });
    });
  });
});


/***/ }),

/***/ "./test/toHaveCalculable.spec.js":
/*!***************************************!*\
  !*** ./test/toHaveCalculable.spec.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveX = __webpack_require__(/*! ./lib/describeToHaveX */ "./test/lib/describeToHaveX.js");

describe('toHaveCalculable', () => {
  describeToHaveX('toHaveCalculable', () => {
    describe('when subject CAN be coerced to be used in mathematical operations', () => {
      it('should confirm', () => {
        expect({
          memberName: '1'
        }).toHaveCalculable('memberName');
        expect({
          memberName: ''
        }).toHaveCalculable('memberName');
        expect({
          memberName: null
        }).toHaveCalculable('memberName');
      });
    });
    describe('when subject can NOT be coerced by JavaScript to be used in mathematical operations', () => {
      it('should deny', () => {
        expect({
          memberName: {}
        }).not.toHaveCalculable('memberName');
        expect({
          memberName: NaN
        }).not.toHaveCalculable('memberName');
      });
    });
  });
});


/***/ }),

/***/ "./test/toHaveDate.spec.js":
/*!*********************************!*\
  !*** ./test/toHaveDate.spec.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveX = __webpack_require__(/*! ./lib/describeToHaveX */ "./test/lib/describeToHaveX.js");

describe('toHaveDate', () => {
  let mockDate;
  beforeEach(() => {
    mockDate = {
      any: new Date(),
      early: new Date('2013-01-01T00:00:00.000Z'),
      late: new Date('2013-01-01T01:00:00.000Z')
    };
  });
  describeToHaveX('toHaveDate', () => {
    describe('when member is an instance of Date', () => {
      it('should confirm', () => {
        expect({
          memberName: mockDate.any
        }).toHaveDate('memberName');
      });
    });
    describe('when member is NOT an instance of Date', () => {
      it('should deny', () => {
        expect({
          memberName: null
        }).not.toHaveDate('memberName');
      });
    });
  });
});


/***/ }),

/***/ "./test/toHaveDateAfter.spec.js":
/*!**************************************!*\
  !*** ./test/toHaveDateAfter.spec.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveX = __webpack_require__(/*! ./lib/describeToHaveX */ "./test/lib/describeToHaveX.js");

describe('toHaveDateAfter', () => {
  let mockDate;
  beforeEach(() => {
    mockDate = {
      any: new Date(),
      early: new Date('2013-01-01T00:00:00.000Z'),
      late: new Date('2013-01-01T01:00:00.000Z')
    };
  });
  describeToHaveX('toHaveDateAfter', () => {
    describe('when member is an instance of Date', () => {
      describe('when date occurs before another', () => {
        it('should confirm', () => {
          expect({
            memberName: mockDate.late
          }).toHaveDateAfter('memberName', mockDate.early);
        });
      });
      describe('when date does NOT occur before another', () => {
        it('should deny', () => {
          expect({
            memberName: mockDate.early
          }).not.toHaveDateAfter('memberName', mockDate.late);
        });
      });
    });
    describe('when member is NOT an instance of Date', () => {
      it('should deny', () => {
        expect({
          memberName: null
        }).not.toHaveDateAfter('memberName', mockDate.any);
      });
    });
  });
});


/***/ }),

/***/ "./test/toHaveDateBefore.spec.js":
/*!***************************************!*\
  !*** ./test/toHaveDateBefore.spec.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveX = __webpack_require__(/*! ./lib/describeToHaveX */ "./test/lib/describeToHaveX.js");

describeToHaveX('toHaveDateBefore', () => {
  let mockDate;
  beforeEach(() => {
    mockDate = {
      any: new Date(),
      early: new Date('2013-01-01T00:00:00.000Z'),
      late: new Date('2013-01-01T01:00:00.000Z')
    };
  });
  describe('when member is an instance of Date', () => {
    describe('when date occurs before another', () => {
      it('should confirm', () => {
        expect({
          memberName: mockDate.early
        }).toHaveDateBefore('memberName', mockDate.late);
      });
    });
    describe('when date does NOT occur before another', () => {
      it('should deny', () => {
        expect({
          memberName: mockDate.late
        }).not.toHaveDateBefore('memberName', mockDate.early);
      });
    });
  });
  describe('when member is NOT an instance of Date', () => {
    it('should deny', () => {
      expect({
        memberName: null
      }).not.toHaveDateBefore('memberName', mockDate.any);
    });
  });
});


/***/ }),

/***/ "./test/toHaveEmptyArray.spec.js":
/*!***************************************!*\
  !*** ./test/toHaveEmptyArray.spec.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveArrayX = __webpack_require__(/*! ./lib/describeToHaveArrayX */ "./test/lib/describeToHaveArrayX.js");

describe('toHaveEmptyArray', () => {
  describeToHaveArrayX('toHaveEmptyArray', () => {
    describe('when named array has members', () => {
      it('should deny', () => {
        expect({
          memberName: [1, 2, 3]
        }).not.toHaveEmptyArray('memberName');
        expect({
          memberName: ''
        }).not.toHaveEmptyArray('memberName');
      });
    });
    describe('when named array has no members', () => {
      it('should confirm', () => {
        expect({
          memberName: []
        }).toHaveEmptyArray('memberName');
      });
    });
  });
});


/***/ }),

/***/ "./test/toHaveEmptyObject.spec.js":
/*!****************************************!*\
  !*** ./test/toHaveEmptyObject.spec.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveX = __webpack_require__(/*! ./lib/describeToHaveX */ "./test/lib/describeToHaveX.js");

describe('toHaveEmptyObject', () => {
  let Foo;
  beforeEach(() => {
    Foo = function() {};
  });
  describeToHaveX('toHaveEmptyObject', () => {
    describe('when subject IS an Object with no instance members', () => {
      beforeEach(() => {
        Foo.prototype = {
          b: 2
        };
      });
      it('should confirm', () => {
        expect({
          memberName: new Foo()
        }).toHaveEmptyObject('memberName');
        expect({
          memberName: {}
        }).toHaveEmptyObject('memberName');
      });
    });
    describe('when subject is NOT an Object with no instance members', () => {
      it('should deny', () => {
        expect({
          memberName: {
            a: 1
          }
        }).not.toHaveEmptyObject('memberName');
        expect({
          memberName: null
        }).not.toHaveNonEmptyObject('memberName');
      });
    });
  });
});


/***/ }),

/***/ "./test/toHaveEmptyString.spec.js":
/*!****************************************!*\
  !*** ./test/toHaveEmptyString.spec.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveX = __webpack_require__(/*! ./lib/describeToHaveX */ "./test/lib/describeToHaveX.js");

describe('toHaveEmptyString', () => {
  describeToHaveX('toHaveEmptyString', () => {
    describe('when subject IS a string with no characters', () => {
      it('should confirm', () => {
        expect({
          memberName: ''
        }).toHaveEmptyString('memberName');
      });
    });
    describe('when subject is NOT a string with no characters', () => {
      it('should deny', () => {
        expect({
          memberName: ' '
        }).not.toHaveEmptyString('memberName');
      });
    });
  });
});


/***/ }),

/***/ "./test/toHaveEvenNumber.spec.js":
/*!***************************************!*\
  !*** ./test/toHaveEvenNumber.spec.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveX = __webpack_require__(/*! ./lib/describeToHaveX */ "./test/lib/describeToHaveX.js");

describe('toHaveEvenNumber', () => {
  describeToHaveX('toHaveEvenNumber', () => {
    describe('when subject IS an even number', () => {
      it('should confirm', () => {
        expect({
          memberName: 2
        }).toHaveEvenNumber('memberName');
      });
    });
    describe('when subject is NOT an even number', () => {
      it('should deny', () => {
        expect({
          memberName: 1
        }).not.toHaveEvenNumber('memberName');
        expect({
          memberName: NaN
        }).not.toHaveEvenNumber('memberName');
      });
    });
  });
});


/***/ }),

/***/ "./test/toHaveFalse.spec.js":
/*!**********************************!*\
  !*** ./test/toHaveFalse.spec.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveBooleanX = __webpack_require__(/*! ./lib/describeToHaveBooleanX */ "./test/lib/describeToHaveBooleanX.js");

describe('toHaveFalse', () => {
  describeToHaveBooleanX('toHaveFalse', () => {
    describe('when primitive', () => {
      describe('when true', () => {
        it('should deny', () => {
          expect({
            memberName: true
          }).not.toHaveFalse('memberName');
        });
      });
      describe('when false', () => {
        it('should confirm', () => {
          expect({
            memberName: false
          }).toHaveFalse('memberName');
        });
      });
    });
    describe('when Boolean object', () => {
      describe('when true', () => {
        it('should deny', () => {
          expect({
            memberName: new Boolean(true)
          }).not.toHaveFalse('memberName');
        });
      });
      describe('when false', () => {
        it('should confirm', () => {
          expect({
            memberName: new Boolean(false)
          }).toHaveFalse('memberName');
        });
      });
    });
  });
});


/***/ }),

/***/ "./test/toHaveHtmlString.spec.js":
/*!***************************************!*\
  !*** ./test/toHaveHtmlString.spec.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveX = __webpack_require__(/*! ./lib/describeToHaveX */ "./test/lib/describeToHaveX.js");

describe('toHaveHtmlString', () => {
  describeToHaveX('toHaveHtmlString', () => {
    describe('when subject IS a string of HTML markup', () => {
      let ngMultiLine;
      beforeEach(() => {
        ngMultiLine = '';
        ngMultiLine +=
          '<a data-ng-href="//www.google.com" data-ng-click="launchApp($event)" target="_blank" class="ng-binding" href="//www.google.com">';
        ngMultiLine += '\n';
        ngMultiLine += '  Watch with Google TV';
        ngMultiLine += '\n';
        ngMultiLine += '</a>';
        ngMultiLine += '\n';
      });
      it('should confirm', () => {
        expect({
          memberName: '<element>text</element>'
        }).toHaveHtmlString('memberName');
        expect({
          memberName:
            '<a data-ng-href="//foo.com" data-ng-click="bar($event)">baz</a>'
        }).toHaveHtmlString('memberName');
        expect({
          memberName: '<div ng-if="foo > bar || bar < foo && baz == bar"></div>'
        }).toHaveHtmlString('memberName');
        expect({
          memberName: '<li ng-if="foo > bar || bar < foo && baz == bar">'
        }).toHaveHtmlString('memberName');
        expect({
          memberName: ngMultiLine
        }).toHaveHtmlString('memberName');
      });
    });
    describe('when subject is NOT a string of HTML markup', () => {
      it('should deny', () => {
        expect({
          memberName: 'div'
        }).not.toHaveHtmlString('memberName');
        expect({
          memberName: null
        }).not.toHaveHtmlString('memberName');
      });
    });
  });
});


/***/ }),

/***/ "./test/toHaveIso8601.spec.js":
/*!************************************!*\
  !*** ./test/toHaveIso8601.spec.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveX = __webpack_require__(/*! ./lib/describeToHaveX */ "./test/lib/describeToHaveX.js");

describe('toHaveIso8601', () => {
  describeToHaveX('toHaveIso8601', () => {
    describe('when member is a Date String conforming to the ISO 8601 standard', () => {
      describe('when specified date is valid', () => {
        it('should confirm', () => {
          expect({
            memberName: '2013-07-08T07:29:15.863Z'
          }).toHaveIso8601('memberName');
          expect({
            memberName: '2013-07-08T07:29:15.863'
          }).toHaveIso8601('memberName');
          expect({
            memberName: '2013-07-08T07:29:15'
          }).toHaveIso8601('memberName');
          expect({
            memberName: '2013-07-08T07:29'
          }).toHaveIso8601('memberName');
          expect({
            memberName: '2013-07-08'
          }).toHaveIso8601('memberName');
        });
      });
      describe('when specified date is NOT valid', () => {
        it('should deny', () => {
          expect({
            memberName: '2013-99-12T00:00:00.000Z'
          }).not.toHaveIso8601('memberName');
          expect({
            memberName: '2013-12-99T00:00:00.000Z'
          }).not.toHaveIso8601('memberName');
          expect({
            memberName: '2013-01-01T99:00:00.000Z'
          }).not.toHaveIso8601('memberName');
          expect({
            memberName: '2013-01-01T99:99:00.000Z'
          }).not.toHaveIso8601('memberName');
          expect({
            memberName: '2013-01-01T00:00:99.000Z'
          }).not.toHaveIso8601('memberName');
        });
      });
    });
    describe('when member is a String NOT conforming to the ISO 8601 standard', () => {
      it('should deny', () => {
        expect({
          memberName: '2013-07-08T07:29:15.'
        }).not.toHaveIso8601('memberName');
        expect({
          memberName: '2013-07-08T07:29:'
        }).not.toHaveIso8601('memberName');
        expect({
          memberName: '2013-07-08T07:2'
        }).not.toHaveIso8601('memberName');
        expect({
          memberName: '2013-07-08T07:'
        }).not.toHaveIso8601('memberName');
        expect({
          memberName: '2013-07-08T07'
        }).not.toHaveIso8601('memberName');
        expect({
          memberName: '2013-07-08T'
        }).not.toHaveIso8601('memberName');
        expect({
          memberName: '2013-07-0'
        }).not.toHaveIso8601('memberName');
        expect({
          memberName: '2013-07-'
        }).not.toHaveIso8601('memberName');
        expect({
          memberName: '2013-07'
        }).not.toHaveIso8601('memberName');
        expect({
          memberName: '2013-0'
        }).not.toHaveIso8601('memberName');
        expect({
          memberName: '2013-'
        }).not.toHaveIso8601('memberName');
        expect({
          memberName: '2013'
        }).not.toHaveIso8601('memberName');
        expect({
          memberName: '201'
        }).not.toHaveIso8601('memberName');
        expect({
          memberName: '20'
        }).not.toHaveIso8601('memberName');
        expect({
          memberName: '2'
        }).not.toHaveIso8601('memberName');
        expect({
          memberName: ''
        }).not.toHaveIso8601('memberName');
      });
    });
  });
});


/***/ }),

/***/ "./test/toHaveJsonString.spec.js":
/*!***************************************!*\
  !*** ./test/toHaveJsonString.spec.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveX = __webpack_require__(/*! ./lib/describeToHaveX */ "./test/lib/describeToHaveX.js");

describe('toHaveJsonString', () => {
  describeToHaveX('toHaveJsonString', () => {
    describe('when subject IS a string of parseable JSON', () => {
      it('should confirm', () => {
        expect({
          memberName: '{}'
        }).toHaveJsonString('memberName');
        expect({
          memberName: '[]'
        }).toHaveJsonString('memberName');
        expect({
          memberName: '[1]'
        }).toHaveJsonString('memberName');
      });
    });
    describe('when subject is NOT a string of parseable JSON', () => {
      it('should deny', () => {
        let _undefined;
        expect({
          memberName: '[1,]'
        }).not.toHaveJsonString('memberName');
        expect({
          memberName: '<>'
        }).not.toHaveJsonString('memberName');
        expect({
          memberName: null
        }).not.toHaveJsonString('memberName');
        expect({
          memberName: ''
        }).not.toHaveJsonString('memberName');
        expect({
          memberName: _undefined
        }).not.toHaveJsonString('memberName');
      });
    });
  });
});


/***/ }),

/***/ "./test/toHaveMember.spec.js":
/*!***********************************!*\
  !*** ./test/toHaveMember.spec.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveX = __webpack_require__(/*! ./lib/describeToHaveX */ "./test/lib/describeToHaveX.js");

describe('toHaveMember', () => {
  describeToHaveX('toHaveMember', () => {});
});


/***/ }),

/***/ "./test/toHaveMethod.spec.js":
/*!***********************************!*\
  !*** ./test/toHaveMethod.spec.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveX = __webpack_require__(/*! ./lib/describeToHaveX */ "./test/lib/describeToHaveX.js");

describe('toHaveMethod', () => {
  describeToHaveX('toHaveMethod', () => {
    describe('when subject IS a function', () => {
      it('should confirm', () => {
        expect({
          memberName() {}
        }).toHaveMethod('memberName');
      });
    });
    describe('when subject is NOT a function', () => {
      it('should deny', () => {
        expect({
          memberName: /regexp/
        }).not.toHaveMethod('memberName');
      });
    });
  });
});


/***/ }),

/***/ "./test/toHaveNonEmptyArray.spec.js":
/*!******************************************!*\
  !*** ./test/toHaveNonEmptyArray.spec.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveArrayX = __webpack_require__(/*! ./lib/describeToHaveArrayX */ "./test/lib/describeToHaveArrayX.js");

describe('toHaveNonEmptyArray', () => {
  describeToHaveArrayX('toHaveNonEmptyArray', () => {
    describe('when named array has no members', () => {
      it('should deny', () => {
        expect({
          memberName: []
        }).not.toHaveNonEmptyArray('memberName');
      });
    });
    describe('when named array has members', () => {
      it('should confirm', () => {
        expect({
          memberName: [1, 2, 3]
        }).toHaveNonEmptyArray('memberName');
      });
    });
  });
});


/***/ }),

/***/ "./test/toHaveNonEmptyObject.spec.js":
/*!*******************************************!*\
  !*** ./test/toHaveNonEmptyObject.spec.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveX = __webpack_require__(/*! ./lib/describeToHaveX */ "./test/lib/describeToHaveX.js");

describe('toHaveNonEmptyObject', () => {
  describeToHaveX('toHaveNonEmptyObject', () => {
    let Foo;
    beforeEach(() => {
      Foo = function() {};
    });
    describe('when subject IS an Object with at least one instance member', () => {
      it('should confirm', () => {
        expect({
          memberName: {
            a: 1
          }
        }).toHaveNonEmptyObject('memberName');
      });
    });
    describe('when subject is NOT an Object with at least one instance member', () => {
      beforeEach(() => {
        Foo.prototype = {
          b: 2
        };
      });
      it('should deny', () => {
        expect({
          memberName: new Foo()
        }).not.toHaveNonEmptyObject('memberName');
        expect({
          memberName: {}
        }).not.toHaveNonEmptyObject('memberName');
        expect({
          memberName: null
        }).not.toHaveNonEmptyObject('memberName');
      });
    });
  });
});


/***/ }),

/***/ "./test/toHaveNonEmptyString.spec.js":
/*!*******************************************!*\
  !*** ./test/toHaveNonEmptyString.spec.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveX = __webpack_require__(/*! ./lib/describeToHaveX */ "./test/lib/describeToHaveX.js");

describe('toHaveNonEmptyString', () => {
  describeToHaveX('toHaveNonEmptyString', () => {
    describe('when subject IS a string with at least one character', () => {
      it('should confirm', () => {
        expect({
          memberName: ' '
        }).toHaveNonEmptyString('memberName');
      });
    });
    describe('when subject is NOT a string with at least one character', () => {
      it('should deny', () => {
        expect({
          memberName: ''
        }).not.toHaveNonEmptyString('memberName');
        expect({
          memberName: null
        }).not.toHaveNonEmptyString('memberName');
      });
    });
  });
});


/***/ }),

/***/ "./test/toHaveNumber.spec.js":
/*!***********************************!*\
  !*** ./test/toHaveNumber.spec.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveX = __webpack_require__(/*! ./lib/describeToHaveX */ "./test/lib/describeToHaveX.js");

describe('toHaveNumber', () => {
  describeToHaveX('toHaveNumber', () => {
    describe('when subject IS a number', () => {
      it('should confirm', () => {
        expect({
          memberName: 1
        }).toHaveNumber('memberName');
        expect({
          memberName: 1.11
        }).toHaveNumber('memberName');
        expect({
          memberName: 1e3
        }).toHaveNumber('memberName');
        expect({
          memberName: 0.11
        }).toHaveNumber('memberName');
        expect({
          memberName: -11
        }).toHaveNumber('memberName');
      });
    });
    describe('when subject is NOT a number', () => {
      it('should deny', () => {
        expect({
          memberName: '1'
        }).not.toHaveNumber('memberName');
        expect({
          memberName: NaN
        }).not.toHaveNumber('memberName');
      });
    });
  });
});


/***/ }),

/***/ "./test/toHaveNumberWithinRange.spec.js":
/*!**********************************************!*\
  !*** ./test/toHaveNumberWithinRange.spec.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveX = __webpack_require__(/*! ./lib/describeToHaveX */ "./test/lib/describeToHaveX.js");

describe('toHaveNumberWithinRange', () => {
  describeToHaveX('toHaveNumberWithinRange', () => {
    describe('when subject IS a number >= floor and <= ceiling', () => {
      it('should confirm', () => {
        expect({
          memberName: 0
        }).toHaveNumberWithinRange('memberName', 0, 2);
        expect({
          memberName: 1
        }).toHaveNumberWithinRange('memberName', 0, 2);
        expect({
          memberName: 2
        }).toHaveNumberWithinRange('memberName', 0, 2);
      });
    });
    describe('when subject is NOT a number >= floor and <= ceiling', () => {
      it('should deny', () => {
        expect({
          memberName: -3
        }).not.toHaveNumberWithinRange('memberName', 0, 2);
        expect({
          memberName: -2
        }).not.toHaveNumberWithinRange('memberName', 0, 2);
        expect({
          memberName: -1
        }).not.toHaveNumberWithinRange('memberName', 0, 2);
        expect({
          memberName: 3
        }).not.toHaveNumberWithinRange('memberName', 0, 2);
        expect({
          memberName: NaN
        }).not.toHaveNumberWithinRange('memberName', 0, 2);
      });
    });
  });
});


/***/ }),

/***/ "./test/toHaveObject.spec.js":
/*!***********************************!*\
  !*** ./test/toHaveObject.spec.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveX = __webpack_require__(/*! ./lib/describeToHaveX */ "./test/lib/describeToHaveX.js");

describe('toHaveObject', () => {
  describeToHaveX('toHaveObject', () => {
    let Foo;
    beforeEach(() => {
      Foo = function() {};
    });
    describe('when subject IS an Object', () => {
      it('should confirm', () => {
        expect({
          memberName: new Object()
        }).toHaveObject('memberName');
        expect({
          memberName: new Foo()
        }).toHaveObject('memberName');
        expect({
          memberName: {}
        }).toHaveObject('memberName');
      });
    });
    describe('when subject is NOT an Object', () => {
      it('should deny', () => {
        expect({
          memberName: null
        }).not.toHaveObject('memberName');
        expect({
          memberName: 123
        }).not.toHaveObject('memberName');
        expect({
          memberName: '[object Object]'
        }).not.toHaveObject('memberName');
      });
    });
  });
});


/***/ }),

/***/ "./test/toHaveOddNumber.spec.js":
/*!**************************************!*\
  !*** ./test/toHaveOddNumber.spec.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveX = __webpack_require__(/*! ./lib/describeToHaveX */ "./test/lib/describeToHaveX.js");

describe('toHaveOddNumber', () => {
  describeToHaveX('toHaveOddNumber', () => {
    describe('when subject IS an odd number', () => {
      it('should confirm', () => {
        expect({
          memberName: 1
        }).toHaveOddNumber('memberName');
      });
    });
    describe('when subject is NOT an odd number', () => {
      it('should deny', () => {
        expect({
          memberName: 2
        }).not.toHaveOddNumber('memberName');
        expect({
          memberName: NaN
        }).not.toHaveOddNumber('memberName');
      });
    });
  });
});


/***/ }),

/***/ "./test/toHaveString.spec.js":
/*!***********************************!*\
  !*** ./test/toHaveString.spec.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveX = __webpack_require__(/*! ./lib/describeToHaveX */ "./test/lib/describeToHaveX.js");

describe('toHaveString', () => {
  describeToHaveX('toHaveString', () => {
    describe('when subject IS a string of any length', () => {
      it('should confirm', () => {
        expect({
          memberName: ''
        }).toHaveString('memberName');
        expect({
          memberName: ' '
        }).toHaveString('memberName');
      });
    });
    describe('when subject is NOT a string of any length', () => {
      it('should deny', () => {
        expect({
          memberName: null
        }).not.toHaveString('memberName');
      });
    });
  });
});


/***/ }),

/***/ "./test/toHaveStringLongerThan.spec.js":
/*!*********************************************!*\
  !*** ./test/toHaveStringLongerThan.spec.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveX = __webpack_require__(/*! ./lib/describeToHaveX */ "./test/lib/describeToHaveX.js");

describe('toHaveStringLongerThan', () => {
  describeToHaveX('toHaveStringLongerThan', () => {
    describe('when the subject and comparison ARE both strings', () => {
      describe('when the subject IS longer than the comparision string', () => {
        it('should confirm', () => {
          expect({
            memberName: 'abc'
          }).toHaveStringLongerThan('memberName', 'ab');
          expect({
            memberName: 'a'
          }).toHaveStringLongerThan('memberName', '');
        });
      });
      describe('when the subject is NOT longer than the comparision string', () => {
        it('should deny', () => {
          expect({
            memberName: 'ab'
          }).not.toHaveStringLongerThan('memberName', 'abc');
          expect({
            memberName: ''
          }).not.toHaveStringLongerThan('memberName', 'a');
        });
      });
    });
    describe('when the subject and comparison are NOT both strings', () => {
      it('should deny (we are asserting the relative lengths of two strings)', () => {
        let _undefined;
        expect({
          memberName: 'truthy'
        }).not.toHaveStringLongerThan('memberName', _undefined);
        expect({
          memberName: _undefined
        }).not.toHaveStringLongerThan('memberName', 'truthy');
        expect({
          memberName: ''
        }).not.toHaveStringLongerThan('memberName', _undefined);
        expect({
          memberName: _undefined
        }).not.toHaveStringLongerThan('memberName', '');
      });
    });
  });
});


/***/ }),

/***/ "./test/toHaveStringSameLengthAs.spec.js":
/*!***********************************************!*\
  !*** ./test/toHaveStringSameLengthAs.spec.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveX = __webpack_require__(/*! ./lib/describeToHaveX */ "./test/lib/describeToHaveX.js");

describe('toHaveStringSameLengthAs', () => {
  describeToHaveX('toHaveStringSameLengthAs', () => {
    describe('when the subject and comparison ARE both strings', () => {
      describe('when the subject IS the same length as the comparision string', () => {
        it('should confirm', () => {
          expect({
            memberName: 'ab'
          }).toHaveStringSameLengthAs('memberName', 'ab');
        });
      });
      describe('when the subject is NOT the same length as the comparision string', () => {
        it('should deny', () => {
          expect({
            memberName: 'abc'
          }).not.toHaveStringSameLengthAs('memberName', 'ab');
          expect({
            memberName: 'a'
          }).not.toHaveStringSameLengthAs('memberName', '');
          expect({
            memberName: ''
          }).not.toHaveStringSameLengthAs('memberName', 'a');
        });
      });
    });
    describe('when the subject and comparison are NOT both strings', () => {
      it('should deny (we are asserting the relative lengths of two strings)', () => {
        let _undefined;
        expect({
          memberName: 'truthy'
        }).not.toHaveStringSameLengthAs('memberName', _undefined);
        expect({
          memberName: _undefined
        }).not.toHaveStringSameLengthAs('memberName', 'truthy');
        expect({
          memberName: ''
        }).not.toHaveStringSameLengthAs('memberName', _undefined);
        expect({
          memberName: _undefined
        }).not.toHaveStringSameLengthAs('memberName', '');
      });
    });
  });
});


/***/ }),

/***/ "./test/toHaveStringShorterThan.spec.js":
/*!**********************************************!*\
  !*** ./test/toHaveStringShorterThan.spec.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveX = __webpack_require__(/*! ./lib/describeToHaveX */ "./test/lib/describeToHaveX.js");

describe('toHaveStringShorterThan', () => {
  describeToHaveX('toHaveStringShorterThan', () => {
    describe('when the subject and comparison ARE both strings', () => {
      describe('when the subject IS shorter than the comparision string', () => {
        it('should confirm', () => {
          expect({
            memberName: 'ab'
          }).toHaveStringShorterThan('memberName', 'abc');
          expect({
            memberName: ''
          }).toHaveStringShorterThan('memberName', 'a');
        });
      });
      describe('when the subject is NOT shorter than the comparision string', () => {
        it('should deny', () => {
          expect({
            memberName: 'abc'
          }).not.toHaveStringShorterThan('memberName', 'ab');
          expect({
            memberName: 'a'
          }).not.toHaveStringShorterThan('memberName', '');
        });
      });
    });
    describe('when the subject and comparison are NOT both strings', () => {
      it('should deny (we are asserting the relative lengths of two strings)', () => {
        let _undefined;
        expect({
          memberName: 'truthy'
        }).not.toHaveStringShorterThan('memberName', _undefined);
        expect({
          memberName: _undefined
        }).not.toHaveStringShorterThan('memberName', 'truthy');
        expect({
          memberName: ''
        }).not.toHaveStringShorterThan('memberName', _undefined);
        expect({
          memberName: _undefined
        }).not.toHaveStringShorterThan('memberName', '');
      });
    });
  });
});


/***/ }),

/***/ "./test/toHaveTrue.spec.js":
/*!*********************************!*\
  !*** ./test/toHaveTrue.spec.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveBooleanX = __webpack_require__(/*! ./lib/describeToHaveBooleanX */ "./test/lib/describeToHaveBooleanX.js");

describe('toHaveTrue', () => {
  describeToHaveBooleanX('toHaveTrue', () => {
    describe('when primitive', () => {
      describe('when true', () => {
        it('should confirm', () => {
          expect({
            memberName: true
          }).toHaveTrue('memberName');
        });
      });
      describe('when false', () => {
        it('should deny', () => {
          expect({
            memberName: false
          }).not.toHaveTrue('memberName');
        });
      });
    });
    describe('when Boolean object', () => {
      describe('when true', () => {
        it('should confirm', () => {
          expect({
            memberName: new Boolean(true)
          }).toHaveTrue('memberName');
        });
      });
      describe('when false', () => {
        it('should deny', () => {
          expect({
            memberName: new Boolean(false)
          }).not.toHaveTrue('memberName');
        });
      });
    });
  });
});


/***/ }),

/***/ "./test/toHaveUndefined.spec.js":
/*!**************************************!*\
  !*** ./test/toHaveUndefined.spec.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveX = __webpack_require__(/*! ./lib/describeToHaveX */ "./test/lib/describeToHaveX.js");

describe('toHaveUndefined', () => {
  describeToHaveX('toHaveUndefined', () => {
    describe('when subject does NOT have a member at the given key', () => {
      it('should deny', () => {
        expect({}).not.toHaveUndefined('memberName');
        expect(null).not.toHaveUndefined('memberName');
      });
    });
    describe('when subject DOES have a member at the given key', () => {
      describe('when subject IS undefined', () => {
        it('should confirm', () => {
          expect({
            memberName: undefined
          }).toHaveUndefined('memberName');
        });
      });
      describe('when subject is NOT undefined', () => {
        it('should deny', () => {
          expect({
            memberName: null
          }).not.toHaveUndefined('memberName');
          expect({
            memberName: 'undefined'
          }).not.toHaveUndefined('memberName');
        });
      });
    });
  });
});


/***/ }),

/***/ "./test/toHaveWhitespaceString.spec.js":
/*!*********************************************!*\
  !*** ./test/toHaveWhitespaceString.spec.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveX = __webpack_require__(/*! ./lib/describeToHaveX */ "./test/lib/describeToHaveX.js");

describe('toHaveWhitespaceString', () => {
  describeToHaveX('toHaveWhitespaceString', () => {
    describe('when subject IS a string containing only tabs, spaces, returns etc', () => {
      it('should confirm', () => {
        expect({
          memberName: ' '
        }).toHaveWhitespaceString('memberName');
        expect({
          memberName: ''
        }).toHaveWhitespaceString('memberName');
      });
    });
    describe('when subject is NOT a string containing only tabs, spaces, returns etc', () => {
      it('should deny', () => {
        expect({
          memberName: 'has-no-whitespace'
        }).not.toHaveWhitespaceString('memberName');
        expect({
          memberName: 'has whitespace'
        }).not.toHaveWhitespaceString('memberName');
        expect({
          memberName: null
        }).not.toHaveWhitespaceString('memberName');
      });
    });
  });
});


/***/ }),

/***/ "./test/toHaveWholeNumber.spec.js":
/*!****************************************!*\
  !*** ./test/toHaveWholeNumber.spec.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const describeToHaveX = __webpack_require__(/*! ./lib/describeToHaveX */ "./test/lib/describeToHaveX.js");

describe('toHaveWholeNumber', () => {
  describeToHaveX('toHaveWholeNumber', () => {
    describe('when subject IS a number with no positive decimal places', () => {
      it('should confirm', () => {
        expect({
          memberName: 1
        }).toHaveWholeNumber('memberName');
        expect({
          memberName: 0
        }).toHaveWholeNumber('memberName');
        expect({
          memberName: 0.0
        }).toHaveWholeNumber('memberName');
      });
    });
    describe('when subject is NOT a number with no positive decimal places', () => {
      it('should deny', () => {
        expect({
          memberName: NaN
        }).not.toHaveWholeNumber('memberName');
        expect({
          memberName: 1.1
        }).not.toHaveWholeNumber('memberName');
        expect({
          memberName: 0.1
        }).not.toHaveWholeNumber('memberName');
      });
    });
  });
});


/***/ }),

/***/ "./test/toStartWith.spec.js":
/*!**********************************!*\
  !*** ./test/toStartWith.spec.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toStartWith', () => {
  describe('when invoked', () => {
    describe('when subject is NOT an undefined or empty string', () => {
      describe('when subject is a string whose leading characters match the expected string', () => {
        it('should confirm', () => {
          expect('jamie').toStartWith('jam');
        });
      });
      describe('when subject is a string whose leading characters DO NOT match the expected string', () => {
        it('should deny', () => {
          expect(' jamie').not.toStartWith('jam');
          expect('Jamie').not.toStartWith('jam');
        });
      });
    });
    describe('when subject IS an undefined or empty string', () => {
      it('should deny', () => {
        let _undefined;
        expect('').not.toStartWith('');
        expect(_undefined).not.toStartWith('');
        expect(_undefined).not.toStartWith('undefined');
        expect('undefined').not.toStartWith(_undefined);
      });
    });
  });
});


/***/ }),

/***/ "./test/toThrowAnyError.spec.js":
/*!**************************************!*\
  !*** ./test/toThrowAnyError.spec.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toThrowAnyError', () => {
  describe('when supplied a function', () => {
    describe('when function errors when invoked', () => {
      let throwError;
      let badReference;
      beforeEach(() => {
        throwError = function() {
          throw new Error('wut?');
        };
        badReference = function() {
          return doesNotExist.someValue; // eslint-disable-line no-undef
        };
      });
      it('should confirm', () => {
        expect(throwError).toThrowAnyError();
        expect(badReference).toThrowAnyError();
      });
    });
    describe('when function does NOT error when invoked', () => {
      let noErrors;
      beforeEach(() => {
        noErrors = function() {};
      });
      it('should deny', () => {
        expect(noErrors).not.toThrowAnyError();
      });
    });
  });
});


/***/ }),

/***/ "./test/toThrowErrorOfType.spec.js":
/*!*****************************************!*\
  !*** ./test/toThrowErrorOfType.spec.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

describe('toThrowErrorOfType', () => {
  describe('when supplied a function', () => {
    describe('when function errors when invoked', () => {
      let throwError;
      let badReference;
      beforeEach(() => {
        throwError = function() {
          throw new Error('wut?');
        };
        badReference = function() {
          return doesNotExist.someValue; // eslint-disable-line no-undef
        };
      });
      describe('when the error is of the expected type', () => {
        it('should confirm', () => {
          expect(throwError).toThrowErrorOfType('Error');
          expect(badReference).toThrowErrorOfType('ReferenceError');
        });
      });
      describe('when the error is NOT of the expected type', () => {
        it('should confirm', () => {
          expect(throwError).not.toThrowErrorOfType('ReferenceError');
          expect(badReference).not.toThrowErrorOfType('Error');
        });
      });
    });
  });
});


/***/ }),

/***/ "./test/whitespace.spec.js":
/*!*********************************!*\
  !*** ./test/whitespace.spec.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const callSpy = __webpack_require__(/*! ./lib/callSpy */ "./test/lib/callSpy.js");

describe('any.whitespace', () => {
  const shared = {};
  beforeEach(() => {
    shared.spy = callSpy(' \n\t ');
  });
  it('should confirm', () => {
    expect(shared.spy).toHaveBeenCalledWith(any.whitespace());
  });
});


/***/ }),

/***/ "./test/wholeNumber.spec.js":
/*!**********************************!*\
  !*** ./test/wholeNumber.spec.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const callSpy = __webpack_require__(/*! ./lib/callSpy */ "./test/lib/callSpy.js");

describe('any.wholeNumber', () => {
  const shared = {};
  beforeEach(() => {
    shared.spy = callSpy(15);
  });
  it('should confirm', () => {
    expect(shared.spy).toHaveBeenCalledWith(any.wholeNumber());
  });
});


/***/ }),

/***/ "./test/withinRange.spec.js":
/*!**********************************!*\
  !*** ./test/withinRange.spec.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const callSpy = __webpack_require__(/*! ./lib/callSpy */ "./test/lib/callSpy.js");

describe('any.withinRange', () => {
  const shared = {};
  beforeEach(() => {
    shared.spy = callSpy(11);
  });
  it('should confirm', () => {
    expect(shared.spy).toHaveBeenCalledWith(any.withinRange(10, 15));
  });
});


/***/ }),

/***/ 0:
/*!**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** multi ./test/after.spec.js ./test/arrayOfBooleans.spec.js ./test/arrayOfNumbers.spec.js ./test/arrayOfObjects.spec.js ./test/arrayOfSize.spec.js ./test/arrayOfStrings.spec.js ./test/before.spec.js ./test/calculable.spec.js ./test/emptyArray.spec.js ./test/emptyObject.spec.js ./test/endingWith.spec.js ./test/evenNumber.spec.js ./test/greaterThanOrEqualTo.spec.js ./test/iso8601.spec.js ./test/jsonString.spec.js ./test/lessThanOrEqualTo.spec.js ./test/longerThan.spec.js ./test/nonEmptyArray.spec.js ./test/nonEmptyObject.spec.js ./test/nonEmptyString.spec.js ./test/oddNumber.spec.js ./test/optionalMessages.spec.js ./test/regExp.spec.js ./test/sameLengthAs.spec.js ./test/shorterThan.spec.js ./test/startingWith.spec.js ./test/toBeAfter.spec.js ./test/toBeArray.spec.js ./test/toBeArrayOfBooleans.spec.js ./test/toBeArrayOfNumbers.spec.js ./test/toBeArrayOfObjects.spec.js ./test/toBeArrayOfSize.spec.js ./test/toBeArrayOfStrings.spec.js ./test/toBeBefore.spec.js ./test/toBeBoolean.spec.js ./test/toBeCalculable.spec.js ./test/toBeDate.spec.js ./test/toBeEmptyArray.spec.js ./test/toBeEmptyObject.spec.js ./test/toBeEmptyString.spec.js ./test/toBeEvenNumber.spec.js ./test/toBeFalse.spec.js ./test/toBeFunction.spec.js ./test/toBeGreaterThanOrEqualTo.spec.js ./test/toBeHtmlString.spec.js ./test/toBeIso8601.spec.js ./test/toBeJsonString.spec.js ./test/toBeLessThanOrEqualTo.spec.js ./test/toBeLongerThan.spec.js ./test/toBeNear.spec.js ./test/toBeNonEmptyArray.spec.js ./test/toBeNonEmptyObject.spec.js ./test/toBeNonEmptyString.spec.js ./test/toBeNumber.spec.js ./test/toBeObject.spec.js ./test/toBeOddNumber.spec.js ./test/toBeRegExp.spec.js ./test/toBeSameLengthAs.spec.js ./test/toBeShorterThan.spec.js ./test/toBeString.spec.js ./test/toBeTrue.spec.js ./test/toBeValidDate.spec.js ./test/toBeWhitespace.spec.js ./test/toBeWholeNumber.spec.js ./test/toBeWithinRange.spec.js ./test/toEndWith.spec.js ./test/toHaveArray.spec.js ./test/toHaveArrayOfBooleans.spec.js ./test/toHaveArrayOfNumbers.spec.js ./test/toHaveArrayOfObjects.spec.js ./test/toHaveArrayOfSize.spec.js ./test/toHaveArrayOfStrings.spec.js ./test/toHaveBoolean.spec.js ./test/toHaveCalculable.spec.js ./test/toHaveDate.spec.js ./test/toHaveDateAfter.spec.js ./test/toHaveDateBefore.spec.js ./test/toHaveEmptyArray.spec.js ./test/toHaveEmptyObject.spec.js ./test/toHaveEmptyString.spec.js ./test/toHaveEvenNumber.spec.js ./test/toHaveFalse.spec.js ./test/toHaveHtmlString.spec.js ./test/toHaveIso8601.spec.js ./test/toHaveJsonString.spec.js ./test/toHaveMember.spec.js ./test/toHaveMethod.spec.js ./test/toHaveNonEmptyArray.spec.js ./test/toHaveNonEmptyObject.spec.js ./test/toHaveNonEmptyString.spec.js ./test/toHaveNumber.spec.js ./test/toHaveNumberWithinRange.spec.js ./test/toHaveObject.spec.js ./test/toHaveOddNumber.spec.js ./test/toHaveString.spec.js ./test/toHaveStringLongerThan.spec.js ./test/toHaveStringSameLengthAs.spec.js ./test/toHaveStringShorterThan.spec.js ./test/toHaveTrue.spec.js ./test/toHaveUndefined.spec.js ./test/toHaveWhitespaceString.spec.js ./test/toHaveWholeNumber.spec.js ./test/toStartWith.spec.js ./test/toThrowAnyError.spec.js ./test/toThrowErrorOfType.spec.js ./test/whitespace.spec.js ./test/wholeNumber.spec.js ./test/withinRange.spec.js ***!
  \**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./test/after.spec.js */"./test/after.spec.js");
__webpack_require__(/*! ./test/arrayOfBooleans.spec.js */"./test/arrayOfBooleans.spec.js");
__webpack_require__(/*! ./test/arrayOfNumbers.spec.js */"./test/arrayOfNumbers.spec.js");
__webpack_require__(/*! ./test/arrayOfObjects.spec.js */"./test/arrayOfObjects.spec.js");
__webpack_require__(/*! ./test/arrayOfSize.spec.js */"./test/arrayOfSize.spec.js");
__webpack_require__(/*! ./test/arrayOfStrings.spec.js */"./test/arrayOfStrings.spec.js");
__webpack_require__(/*! ./test/before.spec.js */"./test/before.spec.js");
__webpack_require__(/*! ./test/calculable.spec.js */"./test/calculable.spec.js");
__webpack_require__(/*! ./test/emptyArray.spec.js */"./test/emptyArray.spec.js");
__webpack_require__(/*! ./test/emptyObject.spec.js */"./test/emptyObject.spec.js");
__webpack_require__(/*! ./test/endingWith.spec.js */"./test/endingWith.spec.js");
__webpack_require__(/*! ./test/evenNumber.spec.js */"./test/evenNumber.spec.js");
__webpack_require__(/*! ./test/greaterThanOrEqualTo.spec.js */"./test/greaterThanOrEqualTo.spec.js");
__webpack_require__(/*! ./test/iso8601.spec.js */"./test/iso8601.spec.js");
__webpack_require__(/*! ./test/jsonString.spec.js */"./test/jsonString.spec.js");
__webpack_require__(/*! ./test/lessThanOrEqualTo.spec.js */"./test/lessThanOrEqualTo.spec.js");
__webpack_require__(/*! ./test/longerThan.spec.js */"./test/longerThan.spec.js");
__webpack_require__(/*! ./test/nonEmptyArray.spec.js */"./test/nonEmptyArray.spec.js");
__webpack_require__(/*! ./test/nonEmptyObject.spec.js */"./test/nonEmptyObject.spec.js");
__webpack_require__(/*! ./test/nonEmptyString.spec.js */"./test/nonEmptyString.spec.js");
__webpack_require__(/*! ./test/oddNumber.spec.js */"./test/oddNumber.spec.js");
__webpack_require__(/*! ./test/optionalMessages.spec.js */"./test/optionalMessages.spec.js");
__webpack_require__(/*! ./test/regExp.spec.js */"./test/regExp.spec.js");
__webpack_require__(/*! ./test/sameLengthAs.spec.js */"./test/sameLengthAs.spec.js");
__webpack_require__(/*! ./test/shorterThan.spec.js */"./test/shorterThan.spec.js");
__webpack_require__(/*! ./test/startingWith.spec.js */"./test/startingWith.spec.js");
__webpack_require__(/*! ./test/toBeAfter.spec.js */"./test/toBeAfter.spec.js");
__webpack_require__(/*! ./test/toBeArray.spec.js */"./test/toBeArray.spec.js");
__webpack_require__(/*! ./test/toBeArrayOfBooleans.spec.js */"./test/toBeArrayOfBooleans.spec.js");
__webpack_require__(/*! ./test/toBeArrayOfNumbers.spec.js */"./test/toBeArrayOfNumbers.spec.js");
__webpack_require__(/*! ./test/toBeArrayOfObjects.spec.js */"./test/toBeArrayOfObjects.spec.js");
__webpack_require__(/*! ./test/toBeArrayOfSize.spec.js */"./test/toBeArrayOfSize.spec.js");
__webpack_require__(/*! ./test/toBeArrayOfStrings.spec.js */"./test/toBeArrayOfStrings.spec.js");
__webpack_require__(/*! ./test/toBeBefore.spec.js */"./test/toBeBefore.spec.js");
__webpack_require__(/*! ./test/toBeBoolean.spec.js */"./test/toBeBoolean.spec.js");
__webpack_require__(/*! ./test/toBeCalculable.spec.js */"./test/toBeCalculable.spec.js");
__webpack_require__(/*! ./test/toBeDate.spec.js */"./test/toBeDate.spec.js");
__webpack_require__(/*! ./test/toBeEmptyArray.spec.js */"./test/toBeEmptyArray.spec.js");
__webpack_require__(/*! ./test/toBeEmptyObject.spec.js */"./test/toBeEmptyObject.spec.js");
__webpack_require__(/*! ./test/toBeEmptyString.spec.js */"./test/toBeEmptyString.spec.js");
__webpack_require__(/*! ./test/toBeEvenNumber.spec.js */"./test/toBeEvenNumber.spec.js");
__webpack_require__(/*! ./test/toBeFalse.spec.js */"./test/toBeFalse.spec.js");
__webpack_require__(/*! ./test/toBeFunction.spec.js */"./test/toBeFunction.spec.js");
__webpack_require__(/*! ./test/toBeGreaterThanOrEqualTo.spec.js */"./test/toBeGreaterThanOrEqualTo.spec.js");
__webpack_require__(/*! ./test/toBeHtmlString.spec.js */"./test/toBeHtmlString.spec.js");
__webpack_require__(/*! ./test/toBeIso8601.spec.js */"./test/toBeIso8601.spec.js");
__webpack_require__(/*! ./test/toBeJsonString.spec.js */"./test/toBeJsonString.spec.js");
__webpack_require__(/*! ./test/toBeLessThanOrEqualTo.spec.js */"./test/toBeLessThanOrEqualTo.spec.js");
__webpack_require__(/*! ./test/toBeLongerThan.spec.js */"./test/toBeLongerThan.spec.js");
__webpack_require__(/*! ./test/toBeNear.spec.js */"./test/toBeNear.spec.js");
__webpack_require__(/*! ./test/toBeNonEmptyArray.spec.js */"./test/toBeNonEmptyArray.spec.js");
__webpack_require__(/*! ./test/toBeNonEmptyObject.spec.js */"./test/toBeNonEmptyObject.spec.js");
__webpack_require__(/*! ./test/toBeNonEmptyString.spec.js */"./test/toBeNonEmptyString.spec.js");
__webpack_require__(/*! ./test/toBeNumber.spec.js */"./test/toBeNumber.spec.js");
__webpack_require__(/*! ./test/toBeObject.spec.js */"./test/toBeObject.spec.js");
__webpack_require__(/*! ./test/toBeOddNumber.spec.js */"./test/toBeOddNumber.spec.js");
__webpack_require__(/*! ./test/toBeRegExp.spec.js */"./test/toBeRegExp.spec.js");
__webpack_require__(/*! ./test/toBeSameLengthAs.spec.js */"./test/toBeSameLengthAs.spec.js");
__webpack_require__(/*! ./test/toBeShorterThan.spec.js */"./test/toBeShorterThan.spec.js");
__webpack_require__(/*! ./test/toBeString.spec.js */"./test/toBeString.spec.js");
__webpack_require__(/*! ./test/toBeTrue.spec.js */"./test/toBeTrue.spec.js");
__webpack_require__(/*! ./test/toBeValidDate.spec.js */"./test/toBeValidDate.spec.js");
__webpack_require__(/*! ./test/toBeWhitespace.spec.js */"./test/toBeWhitespace.spec.js");
__webpack_require__(/*! ./test/toBeWholeNumber.spec.js */"./test/toBeWholeNumber.spec.js");
__webpack_require__(/*! ./test/toBeWithinRange.spec.js */"./test/toBeWithinRange.spec.js");
__webpack_require__(/*! ./test/toEndWith.spec.js */"./test/toEndWith.spec.js");
__webpack_require__(/*! ./test/toHaveArray.spec.js */"./test/toHaveArray.spec.js");
__webpack_require__(/*! ./test/toHaveArrayOfBooleans.spec.js */"./test/toHaveArrayOfBooleans.spec.js");
__webpack_require__(/*! ./test/toHaveArrayOfNumbers.spec.js */"./test/toHaveArrayOfNumbers.spec.js");
__webpack_require__(/*! ./test/toHaveArrayOfObjects.spec.js */"./test/toHaveArrayOfObjects.spec.js");
__webpack_require__(/*! ./test/toHaveArrayOfSize.spec.js */"./test/toHaveArrayOfSize.spec.js");
__webpack_require__(/*! ./test/toHaveArrayOfStrings.spec.js */"./test/toHaveArrayOfStrings.spec.js");
__webpack_require__(/*! ./test/toHaveBoolean.spec.js */"./test/toHaveBoolean.spec.js");
__webpack_require__(/*! ./test/toHaveCalculable.spec.js */"./test/toHaveCalculable.spec.js");
__webpack_require__(/*! ./test/toHaveDate.spec.js */"./test/toHaveDate.spec.js");
__webpack_require__(/*! ./test/toHaveDateAfter.spec.js */"./test/toHaveDateAfter.spec.js");
__webpack_require__(/*! ./test/toHaveDateBefore.spec.js */"./test/toHaveDateBefore.spec.js");
__webpack_require__(/*! ./test/toHaveEmptyArray.spec.js */"./test/toHaveEmptyArray.spec.js");
__webpack_require__(/*! ./test/toHaveEmptyObject.spec.js */"./test/toHaveEmptyObject.spec.js");
__webpack_require__(/*! ./test/toHaveEmptyString.spec.js */"./test/toHaveEmptyString.spec.js");
__webpack_require__(/*! ./test/toHaveEvenNumber.spec.js */"./test/toHaveEvenNumber.spec.js");
__webpack_require__(/*! ./test/toHaveFalse.spec.js */"./test/toHaveFalse.spec.js");
__webpack_require__(/*! ./test/toHaveHtmlString.spec.js */"./test/toHaveHtmlString.spec.js");
__webpack_require__(/*! ./test/toHaveIso8601.spec.js */"./test/toHaveIso8601.spec.js");
__webpack_require__(/*! ./test/toHaveJsonString.spec.js */"./test/toHaveJsonString.spec.js");
__webpack_require__(/*! ./test/toHaveMember.spec.js */"./test/toHaveMember.spec.js");
__webpack_require__(/*! ./test/toHaveMethod.spec.js */"./test/toHaveMethod.spec.js");
__webpack_require__(/*! ./test/toHaveNonEmptyArray.spec.js */"./test/toHaveNonEmptyArray.spec.js");
__webpack_require__(/*! ./test/toHaveNonEmptyObject.spec.js */"./test/toHaveNonEmptyObject.spec.js");
__webpack_require__(/*! ./test/toHaveNonEmptyString.spec.js */"./test/toHaveNonEmptyString.spec.js");
__webpack_require__(/*! ./test/toHaveNumber.spec.js */"./test/toHaveNumber.spec.js");
__webpack_require__(/*! ./test/toHaveNumberWithinRange.spec.js */"./test/toHaveNumberWithinRange.spec.js");
__webpack_require__(/*! ./test/toHaveObject.spec.js */"./test/toHaveObject.spec.js");
__webpack_require__(/*! ./test/toHaveOddNumber.spec.js */"./test/toHaveOddNumber.spec.js");
__webpack_require__(/*! ./test/toHaveString.spec.js */"./test/toHaveString.spec.js");
__webpack_require__(/*! ./test/toHaveStringLongerThan.spec.js */"./test/toHaveStringLongerThan.spec.js");
__webpack_require__(/*! ./test/toHaveStringSameLengthAs.spec.js */"./test/toHaveStringSameLengthAs.spec.js");
__webpack_require__(/*! ./test/toHaveStringShorterThan.spec.js */"./test/toHaveStringShorterThan.spec.js");
__webpack_require__(/*! ./test/toHaveTrue.spec.js */"./test/toHaveTrue.spec.js");
__webpack_require__(/*! ./test/toHaveUndefined.spec.js */"./test/toHaveUndefined.spec.js");
__webpack_require__(/*! ./test/toHaveWhitespaceString.spec.js */"./test/toHaveWhitespaceString.spec.js");
__webpack_require__(/*! ./test/toHaveWholeNumber.spec.js */"./test/toHaveWholeNumber.spec.js");
__webpack_require__(/*! ./test/toStartWith.spec.js */"./test/toStartWith.spec.js");
__webpack_require__(/*! ./test/toThrowAnyError.spec.js */"./test/toThrowAnyError.spec.js");
__webpack_require__(/*! ./test/toThrowErrorOfType.spec.js */"./test/toThrowErrorOfType.spec.js");
__webpack_require__(/*! ./test/whitespace.spec.js */"./test/whitespace.spec.js");
__webpack_require__(/*! ./test/wholeNumber.spec.js */"./test/wholeNumber.spec.js");
module.exports = __webpack_require__(/*! ./test/withinRange.spec.js */"./test/withinRange.spec.js");


/***/ })

/******/ });